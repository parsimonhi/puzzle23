<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<meta name="description" content="Puzzle online">
<title>Puzzle23</title>
<link rel="icon" type="image/svg+xml" href="_icon/puzzle.svg">
<link rel="manifest" href="manifest.json">
<style>
:root
{
	/*
	--u, special length unit
	1rem if viewport width > 20rem
	5vw if 20rem > viewport width > 10rem
	0.5rem if 10rem > viewport width
	*/
	--u:max(0.5rem,min(1rem,5vw));
	/* prefer long hex colors here, required for color input tag */
	--c-light:#ffffff;
	--c-dark:#000000;
	--c-colorful:#0040D0;
	--c-focus:#0040D0;
	--btnSize:min(1.5cm,15vmin);
	--bk-initial:var(--c-light);
	--bk-puzzle:var(--c-light); /* todo: same as pZ.defaultParams.bkc */
	--bk-h1:var(--c-colorful);
	--bk-btn:var(--c-colorful);
	--bk-focus-btn:#ff8800;
	--bk-dlg:var(--c-light);
	--color:var(--c-dark);
	--color-h1:var(--c-light);
	--color-btn:var(--c-light);
	--color-focus-btn:var(--c-light);
	--color-dlg:var(--c-dark);
	--outline-stroke:var(--c-focus);
	--no-borders-stroke:#7777;
	--logo-filter:none;
	--magic-filter:none; /* none or invert(1) */
	--orientation:portrait; /* use a css keyword, not a string */
	--h1-text-shadow:-1px 1px 3px #00f7;
	--shadow:-1px 1px 3px #0007;
}
*
{
	font-family:sans-serif;
}
input
{
	accent-color:var(--c-colorful);
}
html:has(.board.initial)
{
	scroll-behavior:smooth;
}
body
{
	--rf:1;
	--esz00:1;
	--piece-shadow:calc(-1px / var(--rf)) calc(1px / var(--rf)) calc(3px / var(--rf)) #0007;
	margin:0;
	padding:0;
	min-width:10rem;
	color:var(--color);
}
body
{
	background:var(--bk-initial);
}
body:has(.board.puzzle)
{
	-webkit-user-select:none; /* Safari */
	user-select:none;
}
body:has(dialog[open])
{
	overflow:hidden; /* prevent body to be scrolled when a dialog is open */
}
.background
{
	z-index:-2;
	display:block;
	position:fixed;
	top:0;
	left:0;
	width:100vw;
	height:100vh;
}
.background rect
{
	fill:var(--bk-puzzle);
	width:100%;
	height:100%;
}
.selectedArea
{
	position:absolute;
	z-index:3;
	background:#0003;
	pointer-events:none;
}
.board.puzzle,
.board:empty
{
	--img:none;
	position:absolute;
	z-index:1;
	top:0;
	left:0;
	width:100vw;
	height:100vh;
	pointer-events:none;
}
body:has(.selectedArea),
body:has(.selected),
body:has(.ghost.dragInProgress)
{
	/* no scroll allowed when something is selected */
	touch-action:none;
}
body:has(.board.puzzle) header,
body:has(.board.puzzle) footer
{
	display:none;
}
.menu
{
	position:fixed;
	left:0;
	right:0;
	bottom:0;
	display:flex;
	flex-flow:row;
	justify-content:center;
	gap:2vmin;
	list-style-type:none;
	margin:0;
	padding:2vmin;
	pointer-events:none;
}
.menu li
{
	margin:0;
	padding:0;
}
.menu button
{
	background:#0000;
	border:0;
	display:block;
	font-size:0;
	width:var(--btnSize);
    height:var(--btnSize);
    line-height:var(--btnSize);
	margin:0;
	padding:0;
	border-radius:0;
    cursor:pointer;
	pointer-events:auto;
	filter:var(--magic-filter);
}
.menu button img,
.board.initial button.imgSelector img
{
	display:block;
	width:100%;
	height:100%;
}
.stopwatch,
.score
{
	display:flex;
	justify-content:center;
	align-items:center;
	font-size:calc(1.5 * var(--u));
	position:fixed;
	left:0;
	right:0;
	margin:0;
	padding:0.25em 0;
	opacity:0;
	pointer-events:none;
	filter:var(--magic-filter);
}
.stopwatch
{
	top:0;
}
.score
{
	bottom:calc(var(--btnSize) + 4vmin);
}
.stopwatch.show,
.score.show
{
	opacity:1;
}
.messenger
{
	display:block;
	position:fixed;
	top:200vh;
	pointer-events:none;
}
dialog
{
	font-size:1rem;
	hyphens:auto;
	color:var(--color-dlg);
	background:var(--bk-dlg);
	border:0;
	box-shadow:var(--shadow);
}
dialog::backdrop
{
	background-color:#3333;
}
dialog fieldset,dialog form
{
	margin:0;
	padding:0;
	border:0;
}
.noOutline
{
	/* for instance to avoid an outlined h2 when the dialog opens with a click */
	outline:none;
}
dialog ul
{
	list-style-type:none;
}
dialog h2,dialog p,dialog ul
{
	margin:0.25rem 0;
	padding:0;
}
dialog li
{
	margin:0;
	padding:0;
}
dialog .shortcuts>ul>li:first-letter
{
	font-family:Menlo,monospace;
}
dialog .shortcuts>ul>li>ul,
dialog .selectingAndMoving>ul,
dialog .screenReader>ul,
dialog .tipsAndTricksList>li>ul
{
	list-style-type:initial;
	margin:initial;
	padding:initial;
	margin-left:calc(2 * var(--u));
}
dialog .shortcuts>ul>li>ul>li,
dialog .selectingAndMoving>ul>li,
dialog .screenReader>ul>li,
dialog .tipsAndTricksList>li>ul>li
{
	margin:initial;
	padding:initial;
}
dialog .tipsAndTricksList>li
{
	margin:var(--u) 0;
}
dialog .tipsAndTricksList>li:not(:last-of-type)
{
	padding-bottom:var(--u);
	border-bottom:1px solid #000;
}
dialog button
{
	margin:calc(0.5 * var(--u)) calc(0.5 * var(--u)) 0 0;
}
dialog label
{
	display:flex;
	flex-wrap:wrap;
	align-items:center;
	margin:0.25rem 0;
	max-width:max-content;
}
dialog label input, dialog label select
{
	display:inline-block;
	max-width:100%;
	margin:0 calc(0.25 * var(--u));
}
dialog input[type="number"]
{
	width:3rem;
}
dialog input[type="range"]
{
	width:min(100%,11rem);
}
dialog a
{
	color:var(--color-dlg);
}
.figure
{
	position:absolute;
	top:50%;
	left:50%;
	transform:translate(-50%,-50%) scale(var(--rf));
	background-position:center;
	background-repeat:no-repeat;
	background-size:100% auto;
	filter:drop-shadow(var(--piece-shadow));
	margin:0;
	padding:0;
}
.figure.noBorders
{
	filter:none;
}
.figure figcaption
{
	display:block;
	position:absolute;
	margin:0;
	padding:0;
	color:#0000;
}
.puzzleElement
{
	display:block;
	position:absolute;
	stroke-linejoin:round;
	stroke-linecap:round;
	pointer-events:auto;
	outline:none;
	/* use transform below to speed up some safari on macOS and possibly some others? */
	transform:translateZ(0);
	-webkit-tap-highlight-color:transparent;
	touch-action:none;
	transition:filter 0.05s;
}
.puzzleElement.focusInEffect
{
	filter:invert(0.23);
}
.puzzleElement:hover
{
	cursor:pointer;
}
.puzzleElement path
{
	/* #0000 instead of none, otherwise firefox does not return a correct bounding rect */
	fill:#0000;
}
.figure.noBorders .puzzleElement,
.figure:not(:has(svg))
{
	background-image:var(--img);
}
.figure.noBorders .puzzleElement:not(:focus-visible) path,
.figure.noBorders .puzzleElement:not(.selected) path
{
	stroke:var(--no-borders-stroke);
	stroke-width:calc(5px * var(--esz00));
}
.puzzleElement:focus-visible path,
.puzzleElement.selected path,
.figure.noBorders .puzzleElement:focus-visible path,
.figure.noBorders .puzzleElement.selected path
{
	stroke:var(--outline-stroke);
	stroke-width:calc(10px * var(--esz00));
	filter:var(--magic-filter);
}
button:focus-visible,
input:focus-visible,
select:focus-visible,
a:focus-visible,
figure.ghost:focus-visible,
summary:focus-visible
{
	outline:0.125rem solid var(--outline-stroke);
	outline-offset:0.125rem;
}
.wait
{
	display:block;
	position:fixed; /* important for loading speed !?! */
	z-index:2;
	top:50%;
	left:50%;
	transform:translate(-50%,-50%);
	width:20vmin;
	height:20vmin;
	pointer-events:none;
	filter:var(--magic-filter);
}
@keyframes spin
{
	0%{transform:translate(-50%,-50%) rotate(0deg);}
	100%{transform:translate(-50%,-50%) rotate(360deg);}
}
.wait.show
{
	visibility:visible;
	animation:spin 6s linear infinite;
}
.wait.hide
{
	visibility:hidden; /* faster than display:none, no reflow, just repaint */
	animation:none;
}
.board.initial
{
	padding:0 var(--u) var(--u) var(--u);
}
h1,h2,h3
{
	font-family:serif;
}
header
{
	position:relative;
	z-index:-1;
}
h1
{
	display:flex;
	align-items:center;
	font-size:calc(3 * var(--u));
	margin:0;
	padding:0.25em 0.5em;
	color:var(--color-h1);
	background:var(--bk-h1);
	text-shadow:var(--h1-text-shadow);
	box-shadow:var(--shadow);
}
h1:after
{
	content:url('_icon/puzzle.svg');
	border-radius:50%;
	display:block;
	position:absolute;
	bottom:-0.5em;
	right:0.25em;
	width:1.5em;
	min-width:1.5em; /* necessary to avoid the icon to be shrink */
	height:1.5em;
	background:#fff;
	filter:var(--logo-filter);
	filter:drop-shadow(var(--shadow));
}
.board.initial>section.preferences,
.board.initial>section.tipsAndTricks
{
	display:flex;
	flex-wrap:wrap;
	align-items:center;
	gap:calc(2 * var(--u));
	margin:calc(2 * var(--u)) 0;
}
.board.initial>section>h2
{
	display:inline-flex;
	align-items:center;
	font-size:calc(2 * var(--u));
	margin:0;
	padding:0;
}
.board.initial>section.preferences>h2+button,
.board.initial>section.tipsAndTricks>h2+button
{
	flex:0;
}
.board.initial>section.chooseAnImage>h2
{
	margin:0 0 1em 0;
}
.board.initial>section>h2:before
{
	display:inline-block;
	width:1em;
	min-width:1em; /* necessary to avoid the icon to be shrink */
	height:1em;
	margin-right:0.5em;
	padding:0;
}
.board.initial>section.preferences>h2:before
{
	content:url('_icon/preferences.svg');
}
.board.initial>section.tipsAndTricks>h2:before
{
	content:url('_icon/help.svg');
}
.board.initial>section.chooseAnImage>h2:before
{
	content:url('_icon/add-image.svg');
}
.board.initial>section.chooseAnImage>details
{
	margin:0;
	padding:0;
}
.board.initial>section.chooseAnImage>details summary
{
	width:max-content;
	font-size:min(1rem,10vw);
	margin:0.25rem 0;
	padding:0.25rem;
}
.board.initial ul.imgList
{
	/* use columns as default display */
	display:block;
	columns:auto 10rem;
	column-gap:min(0.5rem,5vw);
	list-style-type:none;
	margin:0;
	padding:0;
}
.board.initial ul.imgList li
{
	margin:0 0 0.5rem 0;
	padding:0;
	text-align:center;
	break-inside:avoid;
}
@supports(display:masonry)
{
	/* 2025-11-17, chrome, CSS Masonry Layout flag: enabled */
	.board.initial ul.imgList
	{
		display:masonry;
		columns:initial;
		column-gap:initial;
		gap:min(0.5rem,5vw);
		masonry:repeat(auto-fill,minmax(5rem,1fr));
	}
	.board.initial ul.imgList li
	{
		break-inside:initial;
		max-width:20rem;
		grid-column:span 2;
	}
	.board.initial ul.imgList li:has(img.horizontal)
	{
		grid-column:span 3;
	}
}
@supports(grid-template-rows:masonry)
{
	/* 2025-11-17, firefox, layout.css.grid-template-masonry-value.enabled: true */
	.board.initial ul.imgList
	{
		display:grid;
		columns:initial;
		column-gap:initial;
		gap:min(0.5rem,5vw);
		grid-template-columns:repeat(auto-fill,minmax(5rem,1fr));
		grid-template-rows:masonry;
	}
	.board.initial ul.imgList li
	{
		break-inside:initial;
		max-width:20rem;
		grid-column:span 2;
	}
	.board.initial ul.imgList li:has(img.horizontal)
	{
		grid-column:span 3;
	}
}
.board.initial button.imgSelector
{
	border:0;
	border-radius:0;
	background:0;
	margin:0;
	padding:0;
	width:100%;
}
.board.initial button.imgSelector img
{
	display:block;
	width:100%;
	margin:0 auto;
	padding:0;
	cursor:pointer;
	box-shadow:var(--shadow);
}
.board.initial button.imgAlert
{
	display:inline-block;
	font-size:min(1rem,10vw);
	color:var(--color);
	font-style:italic;
	min-height:1.5rem;
	line-height:1.5rem;
	border:0;
	border-radius:0;
	background:0;
	margin:0.25rem 0;
	padding:0.25rem;
	width:100%;
}
body>footer
{
	padding:0 var(--u);
}
body>footer a
{
	color:var(--color);
}
button.standardBtn,
input::file-selector-button,
dialog button
{
	cursor:pointer;
	padding:0.5rem 1rem;
	border:0;
	border-radius:0.125rem;
	white-space:normal;
	color:var(--color-btn);
	background:var(--bk-btn);
	font-weight:bold;
	box-shadow:var(--shadow);
	text-transform:uppercase;
}
.board.initial>h2:nth-of-type(1)+button.standardBtn
{
	margin-bottom:calc(2 * var(--u));
}
button.standardBtn,
dialog button
{
	display:inline-flex;
	justify-content:center;
	align-items:center;
}
#drop-zone
{
	display:block;
	max-width:max-content;
	margin:0 0 calc(2 * var(--u)) 0;
	padding:var(--u);
	background:#eee;
	box-shadow:var(--shadow);
}
#drop-zone span
{
	display:block;
	padding-bottom:calc(0.5 * var(--u));
}
input[type="file"]
{
	cursor:pointer;
	box-sizing:border-box;
	display:flex;
	flex-wrap:wrap;
	max-width:100%;
	margin:0;
	padding:0.25rem; /* necessary to show the shadow around the button */
	justify-content:center;
	align-content:center;
	white-space:normal;
}
input::file-selector-button
{
	max-width:100%;
	overflow:hidden;
}
button.standardBtn:hover,
input::file-selector-button:hover,
dialog button:hover
{
	color:var(--color-focus-btn);
	background:var(--bk-focus-btn);
}
.ghost
{
	display:none;
	position:fixed;
	z-index:-1;
	top:0;
	right:0;
	overflow:hidden;
	margin:0;
	width:20vmin;
	box-shadow:var(--shadow);
}
.ghost:focus-visible,
.ghost:focus-visible img /* invert img twice voluntarily */
{
	filter:var(--magic-filter);
}
.ghost.show
{
	display:flex;
}
.ghost img
{
	display:block;
	width:100%;
	height:auto;
	pointer-events:none;
}
.ghost:hover
{
	cursor:nesw-resize;
}
footer>a:last-of-type
{
	display:block;
	margin:0 0 var(--u) 0;
}
@supports ((animation-timeline: scroll()) and (animation-range: 0% 100%))
{
	footer>a:last-of-type
	{
		--ws:min(10vmin,1rem);
		font-size:var(--ws);
		position:fixed;
		z-index:100;
		color:transparent;
		background-color:#0003;
		border-radius:50%;
		width:calc(var(--ws) * 4);
		height:calc(var(--ws) * 4);
		overflow:clip;
		right:calc(var(--ws) * 2);
		bottom:calc(var(--ws) * 2);
		margin:0;
		scale:0;
		opacity:0;
		animation:auto linear forwards;
		animation-name:reveal;
		animation-timeline:scroll(y);
		animation-range:33vh 67vh;
	}
	footer>a:last-of-type::before
	{
		content:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12"><path fill="none" stroke="white" d="M6 3V9M3 7L6 3L9 7"/></svg>');
	}
}
@keyframes reveal
{
  to
  {
    opacity:1;
    scale:1;
  }
}
@media (min-aspect-ratio:7/10)
{
	:root
	{
		--orientation:landscape;  /* use a css keyword, not a string */
	}
	.menu
	{
		flex-flow:column;
		top:0;
		bottom:0;
		right:initial;
	}
	.score
	{
		bottom:0;
	}
}
</style>
</head>
<body>
<header><h1>Puzzle23</h1></header>
<script>
(async function()
{
	// do not use arrow functions as methods
	let pZ={};
	// to add a new lang, add its code in the array below
	// and add a translation file in the _i18n folder
	pZ.langs=["en","fr"];
	// common
	pZ.makeLangRegex=function()
	{
		let s="";
		for(let lang of pZ.langs) s+=(s?"|":"")+lang;
		return new RegExp("^("+s+")");
	}
	pZ.getNavigatorLang=function()
	{
		let re=pZ.makeLangRegex();
		if(navigator.languages)
			for(let e of navigator.languages)
				if(e.match(re)) return e.replace(/^(..).*$/,"$1");
		if(navigator.language&&navigator.language.match(es))
			return navigator.language.replace(/^(..).*$/,"$1");
		return "en";
	}
	pZ.getLang=function()
	{
		// test if there is a lang attribute for this script element or one of its parents
		// return the lang if found or return the navigator preferred language
		// if the lang is not en or fr, return en
		let re=pZ.makeLangRegex();
		let e=pZ.currentScript;
		while(e&&!e.lang) e=e.parentNode;
		return (e&&e.lang.match(re))?e.lang:pZ.getNavigatorLang();
	}
	pZ.locale=function(s)
	{
		if((pZ.lang=="en")||!pZ.i18n||!pZ.i18n[pZ.lang]||!pZ.i18n[pZ.lang][s]) return s;
		return pZ.i18n[pZ.lang][s];
	}
	pZ.ucFirst=function(s){return String(s).charAt(0).toUpperCase()+String(s).slice(1);}
	pZ.nearlyEqual=function(a,b){return Math.abs(a-b)<0.01;}
	pZ.hashCode=function(s)
	{
		return s.split('').reduce((a,b)=>{a=((a<<5)-a)+b.charCodeAt(0);return a&a},0);
	}
	pZ.beep=function(d=0.05)
	{
		// recommended to create only one AudioContext
		if(!pZ.acx) pZ.acx=new AudioContext();
		let o=pZ.acx.createOscillator();
		o.connect(pZ.acx.destination);
		o.start();
		o.stop(pZ.acx.currentTime+d);
	}
	pZ.computeRf=function()
	{
		let d=document.documentElement;
		let o=window.getComputedStyle(d).getPropertyValue('--orientation');
		let pp=4,
			sth=pZ.stopwatch.offsetHeight,
		 	sch=pZ.score.offsetHeight,
		 	ms=pZ.accessibility.offsetWidth*19/15,
			bw=pZ.board.offsetWidth,
			bh=pZ.board.offsetHeight,
			fw=pZ.figure.offsetWidth*(pZ.w+Math.floor(pZ.w/10)+pp)/pZ.w,
			fh=pZ.figure.offsetHeight*(pZ.h+Math.floor(pZ.h/10)+pp)/pZ.h;
		// remember that the figure is centered, so -2*ms when portrait
		if(o=="portrait") {bh=bh-2*ms-sth-sch;}
		else {bw=bw-2*ms;bh=bh-sth-sch;}
		return Math.min(bw/fw,bh/fh);
	}
	pZ.computeWH=function()
	{
		pZ.w=Math.max(2,Math.round(Math.sqrt(pZ.whmax*pZ.iw/pZ.ih)));
		pZ.h=Math.ceil(pZ.w*pZ.ih/pZ.iw);
		pZ.wh=pZ.w*pZ.h;
	}
	pZ.resize=function()
	{
		pZ.rf=pZ.computeRf();
		document.body.style.setProperty("--rf",pZ.rf);
	}
	pZ.initScrollArea=function()
	{
		pZ.board.style.removeProperty("transform");
		window.scroll(0,0);
		pZ.dX=0;
		pZ.dY=0;
	}
	pZ.adaptScrollArea=function()
	{
		if(!pZ.figure||!pZ.figcaption||pZ.abortSignal) return;
		let a=pZ.board.getBoundingClientRect();
		let b=pZ.figcaption.getBoundingClientRect();
		let exdX=pZ.dX;
		let exdY=pZ.dY;
		let exdScrollX=window.scrollX;
		let exdScrollY=window.scrollY;
		// adapt
		pZ.figcaption.style.left=(pZ.xmin-pZ.to)+"px";
		pZ.figcaption.style.top=(pZ.ymin-pZ.to)+"px";
		pZ.figcaption.style.width=(pZ.xmax-pZ.xmin+2*pZ.to)+"px";
		pZ.figcaption.style.height=(pZ.ymax-pZ.ymin+2*pZ.to)+"px";
		let c=pZ.board.getBoundingClientRect(),d=pZ.figcaption.getBoundingClientRect();
		let dX=0,dY=0;
		if(d.left<c.left) dX=c.left-d.left;
		if(d.top<c.top) dY=c.top-d.top;
		if(dX||dY) pZ.board.style.transform="translate("+dX+"px,"+dY+"px)";
		else pZ.board.style.removeProperty("transform");
		pZ.dX=dX;
		pZ.dY=dY;
		window.scroll(exdScrollX+dX-exdX,exdScrollY+dY-exdY);
	}
	pZ.centerFigure=function()
	{
		if(!pZ.figure||!pZ.figcaption) return;
		window.scroll(pZ.dX,pZ.dY);
	}
	pZ.doDialog=function(name,title,content,btns)
	{
		let dialog=document.getElementById(name+"Dialog"),b=btns;
		pZ.inDialog=1;
		if(!dialog)
		{
			let s;
			dialog=document.createElement("dialog");
			dialog.id=name+"Dialog";
			s=`<h2 tabindex="0">`+title+`</h2>`;
			s+=`<form method="dialog">`
			+`<fieldset data-dialog-content></fieldset>`
			+`<fieldset data-dialog-menu>`;
			for(let a of b)
			{
				a.v=a.v?a.v:a.n;
				a.l=a.l?a.l:a.n;
				a.t=a.t?a.t:"submit";
				s+=`<button name="${a.n}" type="${a.t}" value="${a.v}">${pZ.locale(a.l)}</button>`;
			}
			dialog.pZ=pZ;
			dialog.addEventListener('close',(ev)=>
			{
				for(let a of b)
					if(a.a&&(dialog.returnValue==a.v)) pZ[`do${a.a}`]();
				pZ.inDialog=0;
			});
			dialog.addEventListener('cancel',(ev)=>
			{
				if(pZ[`do${name}Cancel`]) pZ[`do${name}Cancel`]();
				pZ.inDialog=0;
			});
			s+=`</fieldset>`;
			dialog.innerHTML=s;
			for(let a of b)
			{
				if(a.t=="button")
				{
					let e=dialog.querySelector('[name="'+a.n+'"]');
					e.addEventListener("click",pZ[`do${a.a}`]);
				}
			}
			// put the dialog at the top
			// since when the dialog closes
			// a screen saver may continue the reading after the dialog position
			document.body.prepend(dialog);
		}
		let h2=dialog.querySelector('h2');
		if(pZ.noH2Outline) h2.classList.add("noOutline");
		else h2.classList.remove("noOutline");
		if(name=="Alert") h2.innerHTML=title;
		pZ.noH2Outline=0;
		dialog.querySelector('[data-dialog-content]').innerHTML=content;
		dialog.showModal();
	}
	pZ.doAlert=function(t,s)
	{
		pZ.doDialog("Alert",t,s,[{n:"OK"}]);
	}
	// wait
	pZ.showWait=function()
	{
		if(pZ.figure) pZ.figure.style.setProperty("display","none");
		pZ.wait.classList.replace("hide","show");
	}
	pZ.hideWait=function()
	{
		pZ.wait.classList.replace("show","hide");
	}
	pZ.initWait=function()
	{
		pZ.wait=document.createElement("img");
		pZ.wait.setAttribute("alt",pZ.locale("Please wait!"));
		pZ.wait.setAttribute("width",64);
		pZ.wait.setAttribute("height",64);
		pZ.wait.classList.add("wait","hide");
		pZ.wait.src="_icon/wait.svg";
		pZ.board.after(pZ.wait);
	}
	// alea
	pZ.alea=function(n)
	{
		// return random integer between 0 and n
		return Math.floor(Math.random()*(n+1));
	}
	pZ.shuffleArray=function(a)
	{
		for(let i=a.length-1;i>0;i--)
		{
			let j=pZ.alea(i);
			[a[i],a[j]]=[a[j],a[i]];
		}
		return a;
	}
	pZ.r2d=function(n)
	{
		n=(Math.round(n*20)/20).toFixed(2);
		n=n.replace(/\.00$/,"");
		n=n.replace(/(\.[1-9])0$/,"$1");
		return n;
	}
	pZ.a2A=function(z)
	{
		// round coordinate
		let n=(z+pZ.to)/pZ.esz;
		return pZ.r2d(n+2*pZ.to/pZ.esz);
	}
	pZ.b2B=function(z)
	{
		// round distance
		// assume z>=1
		let n=z/pZ.esz;
		return pZ.r2d(n-2*pZ.to/pZ.esz);
	}
	// tipsAndTricks
	pZ.doTipsAndTricksAlert=function()
	{
		let s="";
		s+="<ul class=\"tipsAndTricksList\">";
		s+="<li>";
		s+="<p>";
		s+=pZ.locale("Are my images sent over the internet?");
		s+="</p><p>";
		s+=pZ.locale("No, this application does not send anything over the internet.");
		s+="</p>";
		s+="</li><li>";
		s+="<p>";
		s+=pZ.locale("Where can I find instructions for keyboard navigation?");
		s+="</p><p>";
		s+=pZ.locale("When a puzzle is displayed, click on the accessibility button.");
		s+="</p>";
		s+="</li><li>";
		s+="<p>";
		s+=pZ.locale("How can I move multiple puzzle pieces simultaneously with the mouse?");
		s+="</p><p>";
		s+=pZ.locale("You can select and then move multiple pieces with the mouse using the following method:");
		s+="</p>";
		s+="<ul>";
		s+="<li>"+pZ.locale("click where there is nothing while holding down the button of the mouse,")+"</li>";
		s+="<li>"+pZ.locale("move the mouse, a grey rectangle appears,")+"</li>";
		s+="<li>"+pZ.locale("release the mouse button; the grey rectangle remains visible, and the pieces inside the rectangle are selected,")+"</li>";
		s+="<li>"+pZ.locale("click on one of the selected pieces while holding down the button of the mouse,")+"</li>";
		s+="<li>"+pZ.locale("move the mouse, all the selected pieces will move,")+"</li>";
		s+="<li>"+pZ.locale("to make the selection rectangle disappear, click somewhere other than on a selected piece.")+"</li>";
		s+="</ul>";
		s+="</li><li>";
		s+="<p>";
		s+=pZ.locale("How do I zoom in and out?");
		s+="</p><p>";
		s+=pZ.locale("Use the browser's zoom function. To reduce (or enlarge) the puzzle pieces while maintaining the initial zoom level for text and buttons, zoom in (or zoom out), then click the Reframe button, then zoom out (or zoom in).");
		s+="</p>";
		s+="</li><li>";
		s+="<p>";
		s+=pZ.locale("How do I change the size of the model image with the mouse?");
		s+="</p><p>";
		s+=pZ.locale("Click on the model image, then move the mouse while holding down its button.");
		s+="</p>";
		s+="</li><li>";
		s+="<p>";
		s+=pZ.locale("When the Rotation option is enabled, how can I rotate the puzzle elements?");
		s+="</p><p>";
		s+=pZ.locale("Simply double-click on it.");
		s+="</p>";
		s+="</li>";
		s+="</ul>";
		pZ.noH2Outline=1;
		pZ.doAlert(pZ.locale("Tips and Tricks"),s);
	}
	pZ.doClickOnTipsAndTricks=function(ev)
	{
		ev.stopPropagation();
		pZ.doTipsAndTricksAlert();
	}
	pZ.initTipsAndTricks=function(container)
	{
		let e=document.createElement('img');
		e.src="_icon/help.svg";
		e.ariaHidden="true";
		e.draggable=false;
		pZ.tipsAndTricks=document.createElement('button');
		pZ.tipsAndTricks.append(e);
		pZ.tipsAndTricks.title=pZ.locale("Tips and Tricks");
		pZ.tipsAndTricks.addEventListener("click",pZ.doClickOnTipsAndTricks);
		container.append(pZ.tipsAndTricks);
	}
	// accessibility
	pZ.doAccessibilityAlert=function()
	{
		let s="";
		s+="<section class=\"screenReader\">";
		s+="<h3>"+pZ.locale("Screen reader")+"</h3>";
		s+="<p>"+pZ.locale("If you are using a screen reader, it is recommended that you choose the following settings:")+"</p>";
		s+="<ul>";
		//s+="<li>"+pZ.locale("Piece type: squared or curvy")+"</li>";
		//s+="<li>"+pZ.locale("Match threshold: 60")+"</li>";
		s+="<li>"+pZ.locale("Keyboard navigation increment: 100")+"</li>";
		s+="<li>"+pZ.locale("Round initial coordinates: checked")+"</li>";
		s+="</ul>";
		s+="<p>";
		s+=pZ.locale("If a puzzle is w pieces wide by h pieces high, the piece in the northwest corner has coordinates (1, 1) and the one in the southeast corner has coordinates (w, h).");
		s+="</p>";
		s+="</section>";
		s+="<section class=\"keyboardNavigation\">";
		s+="<h3>"+pZ.locale("Keyboard navigation")+"</h3>";
		s+="<p>"+pZ.locale("Use the Tab and Shift + Tab keys to move the focus.")+"</p>";
		s+="<p>"+pZ.locale("Use the Enter key or the Space bar to activate a button.")+"</p>";
		s+="</section>";
		s+="<section class=\"shortcuts\">";
		s+="<h3>"+pZ.locale("Shortcuts")+"</h3>";
		s+="<ul>";
		s+="<li><p>a"+pZ.locale(": ")+pZ.locale("open the Accessibility dialog")+"</p></li>";
		s+="<li><p>"+"b"+pZ.locale(": ")+pZ.locale("give the focus to a puzzle element")+"</p>";
		s+="<ul>";
		s+="<li>"+pZ.locale("the next or the first one in the list of elements if a puzzle element is already in focus")+"</li>";
		s+="<li>"+pZ.locale("the last one to have been in focus or the first one on the list of elements if no puzzle element is in focus")+"</li>";
		s+="</ul>";
		s+="</li>";
		s+="<li><p>"+pZ.locale("Shift + ")+"b"+pZ.locale(": ")+pZ.locale("give the focus to a puzzle element")+"</p>";
		s+="<ul>";
		s+="<li>"+pZ.locale("the previous or the last one in the list of elements if a puzzle element is already in focus")+"</li>";
		s+="<li>"+pZ.locale("the last one to have been in focus or the last one on the list of elements if no puzzle element is in focus")+"</li>";
		s+="</ul>";
		s+="</li>";
		s+="<li><p>d"+pZ.locale(": ")+pZ.locale("if a screen reader is activated, describe the selection area if any or the selected puzzle elements if any or the puzzle element in focus")+"</p></li>";
		s+="<li><p>"+pZ.locale("Shift + ")+"d"+pZ.locale(": ")+pZ.locale("if a screen reader is activated, may describe the puzzle elements in more detail (for example, when the type of pieces is \"quirky\")")+"</p>";
		s+="<li><p>e"+pZ.locale(": ")+pZ.locale("reframe the puzzle to fit the window")+"</p></li>";
		s+="<li><p>f"+pZ.locale(": ")+pZ.locale("focus on the model")+"</p></li>";
		s+="<li><p>g"+pZ.locale(": ")+pZ.locale("cancel the selection and blur focus (useful when one then wants to scroll the window content)")+"</p></li>";
		s+="<li><p>h"+pZ.locale(": ")+pZ.locale("focus on the Home button")+"</p></li>";
		s+="<li><p>p"+pZ.locale(": ")+pZ.locale("open the Preferences dialog")+"</p></li>";
		s+="<li><p>r"+pZ.locale(": ")+pZ.locale("focus on the Restart button")+"</p></li>";
		s+="<li><p>t"+pZ.locale(": ")+pZ.locale("open the Tips and Tricks dialog")+"</p></li>";
		s+="</ul>";
		s+="</section>";
		s+="<section class=\"selectingAndMoving\">";
		s+="<h3>"+pZ.locale("Selection and moving")+"</h3>";
		s+="<p>"+pZ.locale("When a puzzle element receives the focus, it is automatically selected and all previously selected elements are unselected.");
		s+=pZ.locale(" Then it can be moved with the arrow keys.")+"</p>";
		s+="<p>"+pZ.locale("It is also possible to select and move one or multiple puzzle elements simultaneously by using a selection area:")+"</p>";
		s+="<ul>";
		s+="<li>"+pZ.locale("Create a selection area with the Shift + arrow keys")+"</li>";
		s+="<li>"+pZ.locale("Enlarge or reduce the selection area with the Shift + arrow keys")+"</li>";
		s+="<li>"+pZ.locale("Move the selection area without its content with the arrow keys")+"</li>";
		s+="<li>"+pZ.locale("Validate the selection of the top most puzzle element that is in the selection area with the Space bar")+"</li>";
		s+="<li>"+pZ.locale("Or validate the selection of all the puzzle elements that are in the selection area with the Shift key + the Space bar")+"</li>";
		s+="<li>"+pZ.locale("Move the selected puzzle elements with the arrow keys")+"</li>";
		s+="</ul>";
		s+="</section>";
		s+="<section class=\"gluing\">";
		s+="<h3>"+pZ.locale("Gluing")+"</h3>";
		s+="<p>"+pZ.locale("Use the Space bar to glue together the selected puzzle elements to its neighbors if they match.")+"</p>";
		s+="</section>";
		s+="<section class=\"misc\">";
		s+="<h3>"+pZ.locale("Miscellaneous")+"</h3>";
		s+="<p>"+pZ.locale("To change the size of the model image, give it the focus then use the arrow keys.")+"</p>";
		s+="<p>"+pZ.locale("When the Rotation option is enabled, to rotate a puzzle element, give it the focus then press Shift key + Spacebar.")+"</p>";
		s+="</section>";
		pZ.noH2Outline=1;
		pZ.doAlert(pZ.locale("Accessibility"),s);
	}
	pZ.doClickOnAccessibility=function(ev)
	{
		ev.stopPropagation();
		pZ.doAccessibilityAlert();
	}
	pZ.initAccessibility=function(container)
	{
		let e=document.createElement('img');
		e.src="_icon/visual-impairments.svg";
		e.ariaHidden="true";
		e.draggable=false;
		pZ.accessibility=document.createElement('button');
		pZ.accessibility.append(e);
		pZ.accessibility.title=pZ.locale("Accessibility");
		pZ.accessibility.addEventListener("click",pZ.doClickOnAccessibility);
		container.append(pZ.accessibility);
	}
	// preferences
	pZ.doPreferencesReset=function()
	{
		let e,list;
		e=document.querySelector('[name="whmax"]');
		e.value=pZ.defaultParams.whmax;
		e=document.querySelector('[name="pt"]');
		e.value=pZ.defaultParams.pt;
		e=document.querySelector('[name="emb"]');
		e.value=pZ.defaultParams.emb;
		e=document.querySelector('[name="th"]');
		e.value=pZ.defaultParams.th;
		e=document.querySelector('[name="ms"]');
		e.value=pZ.defaultParams.ms;
		e=document.querySelector('[name="ro"]');
		e.checked=pZ.defaultParams.ro?true:false;
		e=document.querySelector('[name="ric"]');
		e.checked=pZ.defaultParams.ric?true:false;
		e=document.querySelector('[name="showsw"]');
		e.checked=pZ.defaultParams.showsw?true:false;
		e=document.querySelector('[name="showsc"]');
		e.checked=pZ.defaultParams.showsc?true:false;
		e=document.querySelector('[name="showgh"]');
		e.checked=pZ.defaultParams.showgh?true:false;
		list=Array.from(document.querySelectorAll('[name="scatter"]'));
		list.forEach((e)=>e.checked=(pZ.defaultParams.scatter===e.value));
		e=document.querySelector('[name="bkc"]');
		e.value=pZ.defaultParams.bkc;
		e=document.querySelector('[name="bo"]');
		e.checked=pZ.defaultParams.bo?true:false;
	}
	pZ.makeEmbossFilter=function()
	{
		let roMax=pZ.rotationOn?4:1;
		let fs=[];
		for(let ro=0;ro<roMax;ro++)
		{
			let xs=[],ys=[];
			switch(ro)
			{
				case 1:
					xs=[0,0,-10000,10000,-7000,7000];
					ys=[-10000,10000,0,0,-7000,7000];
					break;
				case 2:
					xs=[0,0,-10000,10000,-7000,7000];
					ys=[10000,-10000,0,0,7000,-7000];
					break;
				case 3:
					xs=[0,0,10000,-10000,7000,-7000];
					ys=[10000,-10000,0,0,7000,-7000];
					break;
				default:
					xs=[0,0,10000,-10000,7000,-7000];
					ys=[-10000,10000,0,0,-7000,7000];
			}
			let s='<filter id="emboss" x="0" y="0" width="100%" height="100%" filterUnits="userSpaceOnUse" primitiveUnits="userSpaceOnUse">';
			s+='<feGaussianBlur stdDeviation="3" in="SourceAlpha" result="G"></feGaussianBlur>';
			s+='<feSpecularLighting surfaceScale="3" specularConstant="0.2" specularExponent="10" in="G" result="L11">';
			s+='<fePointLight x="'+xs[0]+'" y="'+ys[0]+'" z="100"></fePointLight>';
			s+='</feSpecularLighting>';
			s+='<feComposite in="L11" in2="SourceAlpha" operator="in" result="R11"></feComposite>';
			s+='<feSpecularLighting surfaceScale="3" specularConstant="2" specularExponent="10" in="G" result="L12">';
			s+='<fePointLight x="'+xs[1]+'" y="'+ys[1]+'" z="100"></fePointLight>';
			s+='</feSpecularLighting>';
			s+='<feComposite in="L12" in2="SourceAlpha" operator="in" result="R12"></feComposite>';
			s+='<feSpecularLighting surfaceScale="3" specularConstant="0.2" specularExponent="10" in="G" result="L21">';
			s+='<fePointLight x="'+xs[2]+'" y="'+ys[2]+'" z="100"></fePointLight>';
			s+='</feSpecularLighting>';
			s+='<feComposite in="L21" in2="SourceAlpha" operator="in" result="R21"></feComposite>';
			s+='<feSpecularLighting surfaceScale="3" specularConstant="2" specularExponent="10" in="G" result="L22">';
			s+='<fePointLight x="'+xs[3]+'" y="'+ys[3]+'" z="100"></fePointLight>';
			s+='</feSpecularLighting>';
			s+='<feComposite in="L22" in2="SourceAlpha" operator="in" result="R22"></feComposite>';
			s+='<feSpecularLighting surfaceScale="3" specularConstant="0.2" specularExponent="10" in="G" result="L31">';
			s+='<fePointLight x="'+xs[4]+'" y="'+ys[4]+'" z="100"></fePointLight>';
			s+='</feSpecularLighting>';
			s+='<feComposite in="L31" in2="SourceAlpha" operator="in" result="R31"></feComposite>';
			s+='<feSpecularLighting surfaceScale="3" specularConstant="2" specularExponent="10" in="G" result="L32">';
			s+='<fePointLight x="'+xs[5]+'" y="'+ys[5]+'" z="100"></fePointLight>';
			s+='</feSpecularLighting>';
			s+='<feComposite in="L32" in2="SourceAlpha" operator="in" result="R32"></feComposite>';
			s+='<feColorMatrix values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0" in="R12" result="R13"></feColorMatrix>';
			s+='<feComposite k1="0" k2="0.8" k3="0.5" k4="0" in="R11" in2="R13" operator="arithmetic" result="C1"></feComposite>';
			s+='<feColorMatrix values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0" in="R22" result="R23"></feColorMatrix>';
			s+='<feComposite k1="0" k2="0.8" k3="0.5" k4="0" in="R21" in2="R23" operator="arithmetic" result="C2"></feComposite>';
			s+='<feColorMatrix values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0" in="R32" result="R33"></feColorMatrix>';
			s+='<feComposite k1="0" k2="0.8" k3="0.5" k4="0" in="R31" in2="R33" operator="arithmetic" result="C3"></feComposite>';
			s+='<feMerge>';
			s+='<feMergeNode in="SourceGraphic"></feMergeNode>';
			s+='<feMergeNode in="C1"></feMergeNode>';
			s+='<feMergeNode in="C2"></feMergeNode>';
			s+='<feMergeNode in="C3"></feMergeNode>';
			s+='</feMerge>';
			s+='</filter>';
			fs[ro]=s;
		}
    	return fs;
	}
	pZ.computeEsz=function()
	{
		// 200 for magicA is a decent value
		// more means lower quality image (and a faster rendering)
		// less means better quality image (and a slower rendering)
		let magicA=200;
		let r0=pZ.iw/(pZ.w*magicA);
		let esz=Math.round(r0*20)*10; // must be a multiple of 10, otherwise arrow keys do not work properly
		let r1=esz/250;
		let stdD=r1*pZ.emboss;
		let sc=r1*pZ.emboss;
		let roMax=pZ.rotationOn?4:1;
		for(let ro=0;ro<roMax;ro++)
		{
			pZ.embossFilterHtml[ro]=pZ.embossFilterHtml[ro].replace(/stdDeviation="[0-9.]+"/g,"stdDeviation=\""+stdD+"\"");
			pZ.embossFilterHtml[ro]=pZ.embossFilterHtml[ro].replace(/surfaceScale="[0-9.]+"/g,"surfaceScale=\""+sc+"\"");
		}
		return esz;
	}
	pZ.setBkColor=function()
	{
		function hex2Rgb(a)
		{
			// assume a is a long hex color
			let longHex=/^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2}).*$/i;
			let r=a.match(longHex);
			if(r) return [parseInt(r[1],16),parseInt(r[2],16),parseInt(r[3],16)];
			return [255,255,255]; // something is wrong, return a light color
		}
		function isDark(color)
		{
			let r,g,b;
			// ignore transparency
			if (color.match(/^rgb/))
			{
				color=color.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
				if(!color) color=[255,255,255];
				else color=color.slice(1);
  			} 
			else if(color.match(/^#/))
			{
				color=hex2Rgb(color);
			}
			else return 0; // if failed to convert the color, assume it is not a dark color
			r=color[0];
			g=color[1];
			b=color[2];
			// HSP equation from http://alienryderflex.com/hsp.html
			hsp=Math.sqrt(0.299*(r*r)+0.587*(g*g)+0.114*(b*b));
			// Using the HSP value, determine whether the color is light or dark
			return (hsp<127.5);
		}
		document.documentElement.style.setProperty('--bk-puzzle',pZ.bkColor);
		if(isDark(pZ.bkColor)) document.documentElement.style.setProperty('--magic-filter',"invert(1)");
		else document.documentElement.style.setProperty('--magic-filter',"none");
	}
	pZ.doPreferencesOK=function()
	{
		let e,changeStatus=0;
		e=document.querySelector('[name="whmax"]');
		if(e)
		{
			let whmax=parseInt(e.value);
			whmax=!whmax?2:Math.max(2,whmax);
			if(whmax!=pZ.whmax)
			{
				localStorage.pZ_whmax=pZ.whmax=whmax;
				changeStatus|=32;
			}
		}
		e=document.querySelector('[name="pt"]');
		if(e&&(e.value!=pZ.pt))
		{
			localStorage.pZ_pt=pZ.pt=e.value;
			changeStatus|=4;
		}
		e=document.querySelector('[name="emb"]');
		if(e)
		{
			let emb=-(-e.value);
			if(emb!=pZ.emboss)
			{
				localStorage.pZ_emb=pZ.emboss=emb;
				changeStatus|=2;
			}
		}
		e=document.querySelector('[name="th"]');
		if(e)
		{
			let th=-(-e.value);
			th=Math.max(0,Math.min(100,th));
			localStorage.pZ_th=pZ.threshold=th;
		}
		e=document.querySelector('[name="ms"]');
		if(e) localStorage.pZ_ms=pZ.moveStep=-(-e.value);
		e=document.querySelector('[name="ro"]');
		if(e)
		{
			let ro=e.checked?1:0;
			if(ro!=pZ.rotationOn)
			{
				localStorage.pZ_ro=pZ.rotationOn=ro;
				changeStatus|=16;
			}
		}	
		e=document.querySelector('[name="ric"]');
		if(e) localStorage.pZ_ric=pZ.roundInitialCoordinates=e.checked?1:0;
		e=document.querySelector('[name="showsw"]');
		if(e)
		{
			localStorage.pZ_showsw=pZ.showStopwatch=e.checked?1:0;
			if(pZ.stopwatch) pZ.showHideStopwatch();
		}
		e=document.querySelector('[name="showsc"]');
		if(e)
		{
			localStorage.pZ_showsc=pZ.showScore=e.checked?1:0;
			if(pZ.score) pZ.showHideScore();
		}
		e=document.querySelector('[name="showgh"]');
		if(e)
		{
			localStorage.pZ_showgh=pZ.showGhost=e.checked?1:0;
			if(pZ.ghost) pZ.showHideGhost();
		}
		e=document.querySelector('[name="scatter"]:checked');
		if(e&&(e.value!=pZ.scatter))
		{
			localStorage.pZ_scatter=pZ.scatter=e.value;
			changeStatus|=8;
		}
		e=document.querySelector('[name="bkc"]');
		if(e&&(e.value!=pZ.bkColor))
		{
			localStorage.pZ_bkc=pZ.bkColor=e.value;
			pZ.setBkColor();
		}
		e=document.querySelector('[name="bo"]');
		if(e) localStorage.pZ_bo=pZ.beepOn=e.checked?1:0;
		if(pZ.abortSignal) changeStatus|=64;
		if(pZ.board.querySelector('.figure svg')&&changeStatus)
		{
			if((changeStatus==8)||(changeStatus==16)||(changeStatus==24))
			{
				// just change the pieces positions
				if(changeStatus&8) pZ.doScatteringOnly();
				if(changeStatus&16) pZ.doRotationOnly();
			}
			else
			{
				pZ.restoreOn=changeStatus;
				pZ.showWait();
				pZ.clearFigure();
				pZ.resetStopwatch();
				pZ.updateScore();
				setTimeout(()=>pZ.initPuzzle(),100);
			}
		}
	}
	pZ.doPreferencesDialog=function()
	{
		function makeOption(a,b)
		{
			let s="<option value=\""+a+"\""+((b==a)?" selected":"")+">";
			return s+pZ.locale(a)+"</option>";
		}
		function makeCheckbox(a,b,c)
		{
			let s="<label><input name=\""+a+"\" type=\"checkbox\""+(b?" checked":"")+"> ";
			return s+pZ.locale(c)+"</label>";
		}
		function makeRadio(name,value,label,params)
		{
			let s="<p>"+pZ.locale(label)+"</p>";
			for(let p of params)
			{
				s+="<label>";
				s+="<input name=\""+name+"\" value=\""+p.value+"\" type=\"radio\""+((value==p.value)?" checked":"")+"> ";
				s+=pZ.locale(p.label);
				s+="</label>";
			}
			return s;
		}
		function makeColorPicker(a,b,c)
		{
			let s=pZ.locale(c);
			s+="<input name=\""+a+"\" type=\"color\""+(b?" value=\""+b+"\"":"")+"> ";
			return "<label>"+s+"</label>";
		}
		let t=pZ.locale("Preferences"),s="";
		s+="<label>";
		s+=pZ.locale("Number of puzzle pieces (approximate)")+" ";
		s+="<input name=\"whmax\" type=\"number\" min=\"2\" max=\"5000\" value=\""+pZ.whmax+"\">";
		s+="</label>";
		s+="<label>";
		s+=pZ.locale("Piece type")+" ";
		s+="<select name=\"pt\">";
		s+=makeOption("squared",pZ.pt);
		s+=makeOption("curvy",pZ.pt);
		s+=makeOption("quirky",pZ.pt);
		s+="</select>";
		s+="</label>";
		s+="<label>";
		s+=pZ.locale("Emboss")+" ";
		s+="<input name=\"emb\" type=\"range\" min=\"0\" max=\"10\" value=\""+pZ.emboss+"\">";
		s+="</label>";
		s+="<label>";
		s+=pZ.locale("Match threshold (in %)")+" ";
		s+="<input name=\"th\" type=\"number\" min=\"0\" max=\"100\" step=\"5\" value=\""+pZ.threshold+"\">";
		s+="</label>";
		s+="<label>";
		s+=pZ.locale("Keyboard navigation increment (in %)")+" ";
		s+="<select name=\"ms\">";
		s+=makeOption(10,pZ.moveStep);
		s+=makeOption(20,pZ.moveStep);
		s+=makeOption(50,pZ.moveStep);
		s+=makeOption(100,pZ.moveStep);
		s+="</select>";
		s+="</label>";
		s+=makeCheckbox("ro",pZ.rotationOn,"Rotation");
		s+=makeCheckbox("showsw",pZ.showStopwatch,"Show the stopwatch");
		s+=makeCheckbox("showsc",pZ.showScore,"Show the score");
		s+=makeCheckbox("showgh",pZ.showGhost,"Show the model");
		s+=makeCheckbox("ric",pZ.roundInitialCoordinates,"Round initial coordinates");
		s+=makeRadio("scatter",pZ.scatter,"Scattering",[{label:pZ.locale("Inside"),value:"inside"},{label:pZ.locale("Outside"),value:"outside"}]);
		s+=makeColorPicker("bkc",pZ.bkColor,"Background color");
		s+=makeCheckbox("bo",pZ.beepOn,"Beep when matching");
		let o=[{n:"OK",a:"PreferencesOK"},{n:"Cancel"},{n:"Reset",l:"Default values",a:"PreferencesReset",t:"button"}];
		pZ.noH2Outline=1;
		pZ.doDialog("Preferences",t,s,o);
	}
	pZ.doClickOnPreferences=function(ev)
	{
		ev.stopPropagation();
		if(pZ.inInit)
		{
			let s=pZ.locale("Impossible to change the settings while a puzzle is being built!");
			pZ.doAlert(pZ.locale("Alert"),s);
		}
		else pZ.doPreferencesDialog();
	}
	pZ.initPreferences=function(container)
	{
		let e=document.createElement('img');
		e.src="_icon/preferences.svg";
		e.ariaHidden="true";
		e.draggable=false;
		pZ.preferences=document.createElement('button');
		pZ.preferences.classList.add("preferences");
		pZ.preferences.append(e);
		pZ.preferences.title=pZ.locale("Preferences");
		pZ.preferences.addEventListener("click",pZ.doClickOnPreferences);
		container.append(pZ.preferences);
	}
	// reframe
	pZ.reframe=function()
	{
		pZ.resize();
		pZ.adaptScrollArea();
		pZ.centerFigure();
	}
	pZ.doClickOnReframe=function(ev)
	{
		ev.stopPropagation();
		if(pZ.abortSignal||pZ.inInit) return;
		pZ.reframe();
	}
	pZ.initReframe=function(container)
	{
		let e=document.createElement('img');
		e.src="_icon/reframe.svg";
		e.ariaHidden="true";
		e.draggable=false;
		pZ.reframeBtn=document.createElement('button');
		pZ.reframeBtn.classList.add("reframe");
		pZ.reframeBtn.append(e);
		pZ.reframeBtn.title=pZ.locale("Reframe");
		pZ.reframeBtn.addEventListener("click",pZ.doClickOnReframe);
		container.append(pZ.reframeBtn);
	}
	// restart
	pZ.doRestartOK=function()
	{
		pZ.resetScore();
		pZ.resetStopwatch();
		pZ.showWait();
		setTimeout(()=>pZ.initPuzzle(),100);
	}
	pZ.doRestartDialog=function()
	{
		let t=pZ.locale("Restart"),s="";
		s+="<p>";
		s+=pZ.locale("The puzzle has not been completed.");
		s+="</p>";
		s+="<p>";
		s+=pZ.locale("Do you still want to restart it?");
		s+="</p>";
		let o=[{n:"Yes",a:"RestartOK"},{n:"No"}];
		pZ.noH2Outline=1;
		pZ.doDialog("Restart",t,s,o);
	}
	pZ.doClickOnRestart=function(ev)
	{
		ev.stopPropagation();
		if(pZ.abortSignal) return;
		if(pZ.inInit)
		{
			let s=pZ.locale("Impossible to restart while a puzzle is being built!");
			pZ.doAlert(pZ.locale("Alert"),s);
		}
		else if(pZ.dirty) pZ.doRestartDialog();
		else pZ.doRestartOK();
	}
	pZ.initRestart=function(container)
	{
		// link in a button
		let e=document.createElement('img');
		e.src="_icon/restart.svg";
		e.ariaHidden="true";
		e.draggable=false;
		pZ.restart=document.createElement('button');
		pZ.restart.classList.add("restart");
		pZ.restart.append(e);
		pZ.restart.title=pZ.locale("Restart");
		pZ.restart.addEventListener("click",pZ.doClickOnRestart);
		container.append(pZ.restart);
	}
	// home
	pZ.doClickOnHome=function(ev)
	{
		location.href="./"+pZ.search;
	}
	pZ.initHome=function(container)
	{
		// link in a button
		let e=document.createElement('img');
		e.src="_icon/home.svg";
		e.ariaHidden="true";
		e.draggable=false;
		pZ.home=document.createElement('button');
		pZ.home.classList.add("home");
		pZ.home.append(e);
		pZ.home.title=pZ.locale("Home");
		pZ.home.addEventListener("click",pZ.doClickOnHome);
		container.append(pZ.home);
	}
	// menu
	pZ.initMenuItem=function(item)
	{
		let li=document.createElement('li');
		pZ.menu.append(li);
		pZ["init"+item](li);
	}
	pZ.initMenu=function()
	{
		pZ.menu=document.createElement('menu');
		pZ.menu.classList.add("menu");
		pZ.initMenuItem("Accessibility");
		pZ.initMenuItem("TipsAndTricks");
		pZ.initMenuItem("Preferences");
		pZ.initMenuItem("Reframe");
		pZ.initMenuItem("Restart");
		pZ.initMenuItem("Home");
		pZ.board.before(pZ.menu);
	}
	// open using an image on user's device
	pZ.setWHToSvg=function(svgAsTxt)
	{
		let figure=document.createElement("figure");
		figure.innerHTML=svgAsTxt;
		let svg=figure.querySelector("svg");
		let x=0,y=0,w=0,h=0;
		if(svg.viewBox)
		{
			let box=svg.viewBox.baseVal;
			x=box.x;
			y=box.y;
			w=box.width;
			h=box.height;
		}
		if(!w||!h)
		{
			if(svg.width&&svg.width.baseVal&&svg.width.baseVal.valueAsString)
			{
				let sw=svg.width.baseVal.valueAsString;
				if(sw.match(/^[0-9.]+(px)?$/)) w=-(-sw.replace(/^([0-9.]+)(px)?$/,"$1"));
			}
			if(svg.height&&svg.height.baseVal&&svg.height.baseVal.valueAsString)
			{
				let sh=svg.height.baseVal.valueAsString;
				if(sh.match(/^[0-9.]+(px)?$/)) h=-(-sh.replace(/^([0-9.]+)(px)?$/,"$1"));
			}
		}
		if(!w||!h)
		{
			w=300;
			h=150;
		}
		svg.setAttribute("viewBox",x+" "+y+" "+w+" "+h);
		if(w<h)
		{
			svg.setAttribute("width",Math.floor(pZ.iwhMax*w/h));
			svg.setAttribute("height",pZ.iwhMax);
		}
		else
		{
			svg.setAttribute("width",pZ.iwhMax);
			svg.setAttribute("height",Math.floor(pZ.iwhMax*h/w));
		}
		let data=figure.innerHTML;
		return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
	}
	pZ.loader=function(svgImgOn)
	{
		pZ.imgObj=new Image();
		pZ.imgObj.crossOrigin="anonymous";
		pZ.imgObj.addEventListener("load",()=>
		{
			pZ.board.style.setProperty("--img",`url('${pZ.imgUrl}')`);
			pZ.iw=pZ.imgObj.width;
			pZ.ih=pZ.imgObj.height;
			if(Math.max(pZ.iw,pZ.ih)>pZ.iwhMax)
			{
				let iw=pZ.iw,ih=pZ.ih;
				if(iw<ih){pZ.iw=pZ.iwhMax*iw/ih;pZ.ih=pZ.iwhMax;}
				else{pZ.iw=pZ.iwhMax;pZ.ih=pZ.iwhMax*ih/iw;}
				pZ.iw=Math.floor(pZ.iw);
				pZ.ih=Math.floor(pZ.ih);
				let o={resizeWidth:pZ.iw,resizeHeight:pZ.ih,resizeQuality:"high"};
				createImageBitmap(pZ.imgObj,o)
				.then((imgBmp)=>
				{
					pZ.imgBmp=imgBmp;
					pZ.imgDataUrl=pZ.base64Bmp(imgBmp,pZ.iw,pZ.ih);
					pZ.initFirst();
				});
			}
			else pZ.initFirst();
		});
		if(svgImgOn) pZ.imgObj.src=pZ.imgDataUrl;
		else pZ.imgObj.src=pZ.imgUrl;
	}
	pZ.doReadFile=function(f)
	{
		pZ.showWait();
		pZ.imgBmp=null;
		if(!f.type.match(/^image/i))
		{
			pZ.noH2Outline=1;
			pZ.doAlert(pZ.locale("Error"),pZ.locale("Sorry, cannot open this file!"));
			return;
		}
		if(pZ.imgUrlCreated) URL.revokeObjectURL(pZ.imgUrl);
		else pZ.imgUrlCreated=1;
		pZ.imgUrl=URL.createObjectURL(f);
		let svgImgOn=f.type.match(/svg\+xml$/i)?1:0;
		const reader = new FileReader();
		reader.addEventListener("load",()=>
		{
			pZ.board.innerHTML="";
			if(svgImgOn) pZ.imgDataUrl=pZ.setWHToSvg(reader.result);
			else pZ.imgDataUrl=reader.result;
			pZ.loader(svgImgOn);
		});
		if(svgImgOn) reader.readAsText(f);
		else reader.readAsDataURL(f);
	}
	pZ.doChangeFile=function(ev)
	{
		pZ.doReadFile(ev.target.files[0]);
	}
	// score
	pZ.showHideScore=function()
	{
		if(pZ.showScore) pZ.score.classList.add("show");
		else pZ.score.classList.remove("show");
	}
	pZ.updateScore=function()
	{
		let a=pZ.wh;
		if(pZ.figure&&!pZ.abortSignal)
		{
			let score=pZ.figure.querySelectorAll('.puzzleElement').length;
			if(score!==pZ.currentScore)
			{
				if((score!=a)&&pZ.beepOn) pZ.beep();
				pZ.currentScore=score;
				let s=pZ.locale("Elements remaining to be glued");
				pZ.score.setAttribute("aria-label",s);
				pZ.score.innerHTML=score+" / "+a;
				if(score!=a)
				{
					if(!score)
					{
						// announce the game over with a delay
						// to allow screen readers time to announce something else before
						// otherwise, the score may not be announced
						s=pZ.locale("Well done! The puzzle is complete!");
						pZ.setTimeoutId=setTimeout(()=>pZ.updateMessenger(s),3000);
					}
					else
					{
						s=pZ.locale("Match found!")+pZ.locale(" ")+s;
						s+=pZ.locale(": ");
						s+=score+pZ.locale(" out of ")+a;
						pZ.updateMessenger(s);
					}
				}
			}
		}
		else
		{
			// something went wrong, just set score to -1
			pZ.currentScore=-1;
		}
	}
	pZ.resetScore=function()
	{
		pZ.currentScore=-1;
		pZ.score.innerHTML="";
	}
	pZ.initScore=function()
	{
		// 2025-11-24
		// an output tag should be better
		// but safari requires ariaLive="polite" to make it working
		// and in this case it repeats its content twice
		// firefox ignore the aria-label of an output tag (why???)
		// the information provided by this tag is not crucial
		// so one just uses a p tag to inform users silently 
		pZ.score=document.createElement('p');
		pZ.score.classList.add("score");
		pZ.showHideScore();
		pZ.board.after(pZ.score);
	}
	// messenger
	pZ.updateMessenger=function(s)
	{
		if(document.ariaNotify) document.ariaNotify(s,{priority:"high"});
		else
		{
			if(!pZ.messenger)
			{
				// 2025-11-24
				// workaround when the browser does not know document.ariaNotify
				pZ.messenger=document.createElement('p');
				pZ.messenger.ariaLive="assertive";
				pZ.messenger.classList.add("messenger");
				pZ.score.after(pZ.messenger);
			}
			if(s==pZ.messenger.innerHTML) pZ.messenger.innerHTML=s+'&nbsp;'; // beurk
			else pZ.messenger.innerHTML=s;
		}
	}
	// stopwatch
	pZ.showHideStopwatch=function()
	{
		if(pZ.showStopwatch) pZ.stopwatch.classList.add("show");
		else pZ.stopwatch.classList.remove("show");
	}
	pZ.updateStopwatch=function()
	{
		let t=pZ.stopwatchTime,h,m,s,p=(z)=>(z<10)?("0"+z):(""+z);
		s=p(t%60);
		m=p(((t-s)/60)%60);
		h=p((t-s-m*60)/3600);
		pZ.stopwatch.innerHTML=h+":"+m+":"+s;
		localStorage.pZ_stopwatchTime=t;
	}
	pZ.pauseStopwatch=function()
	{
		if(pZ.intervalId) clearInterval(pZ.intervalId);
	}
	pZ.resetStopwatch=function()
	{
		pZ.pauseStopwatch();
		pZ.stopwatchTime=0;
		pZ.updateStopwatch();
	}
	pZ.incrementeStopwatch=function()
	{
		pZ.stopwatchTime++;
		pZ.updateStopwatch();
	}
	pZ.startStopwatch=function()
	{
		pZ.intervalId=setInterval(pZ.incrementeStopwatch,1000);
	}
	pZ.initStopwatch=function()
	{
		let t=localStorage.pZ_stopwatchTime;
		pZ.stopwatchTime=t?-(-t):0;
		pZ.stopwatch=document.createElement('time');
		pZ.stopwatch.classList.add("stopwatch");
		pZ.showHideStopwatch();
		pZ.updateStopwatch(); // need it to compute rf
		pZ.board.before(pZ.stopwatch);
	}
	// ghost
	pZ.dragGhostContinue=function(ev)
	{
		let e=pZ.ghost;
		if(ev.isPrimary&&e&&e.hasPointerCapture(ev.pointerId))
		{
			ev.preventDefault();
			e.classList.add("dragInProgress");
			let dx=pZ.ghostBeforeClientX-ev.clientX;
			let dy=ev.clientY-pZ.ghostBeforeClientY;
			if(dx>(dy*pZ.ghostRatio))
			{
				e.style.width=(pZ.ghostBeforeWidth+dx)+"px";
				e.style.height=(pZ.ghostBeforeWidth+dx)/pZ.ghostRatio+"px";
			}
			else
			{
				e.style.height=(pZ.ghostBeforeHeight+dy)+"px";
				e.style.width=(pZ.ghostBeforeHeight+dy)*pZ.ghostRatio+"px";
			}
		}
	}
	pZ.dragGhostStart=function(ev)
	{
		let e=pZ.ghost;
		ev.preventDefault();
		e.classList.remove("dragInProgress");
		e.addEventListener('pointermove',pZ.dragGhostContinue);
		e.setPointerCapture(ev.pointerId);
		pZ.ghostBeforeClientX=ev.clientX;
		pZ.ghostBeforeClientY=ev.clientY;
		pZ.ghostBeforeWidth=pZ.ghost.offsetWidth;
		pZ.ghostBeforeHeight=pZ.ghost.offsetHeight;
	}
	pZ.dragGhostEnd=function(ev)
	{
		let e=pZ.ghost;
		if(e.hasPointerCapture(ev.pointerId)) e.releasePointerCapture(ev.pointerId);
		pZ.ghost.removeEventListener('pointermove',pZ.dragGhostContinue);
	}
	pZ.setGhostWH=function()
	{
		if(!pZ.ghostRatio)
		{
			let img=pZ.ghost.querySelector('img');
			let h=img.height;
			if(!h) return;
			let w=img.width;
			if(!w) return;
			pZ.ghostRatio=w/h;
		}
		if(pZ.ghostRatio<1)
		{
			let h=window.innerWidth*pZ.gln/100;
			pZ.ghost.style.height=h+"px";
			pZ.ghost.style.width=h*pZ.ghostRatio+"px";
		}
		else
		{
			let w=window.innerWidth*pZ.gln/100;
			pZ.ghost.style.width=w+"px";
			pZ.ghost.style.height=w/pZ.ghostRatio+"px";
		}
	}
    pZ.resizeGhost=function(ev)
    {
    	let r=100/window.innerWidth;
		pZ.gln=((pZ.ghostRatio<1)?pZ.ghost.offsetHeight:pZ.ghost.offsetWidth)*r;
		switch (ev.key)
		{
			case 'ArrowUp':
			case 'ArrowRight':
				pZ.gln=Math.max(pZ.gln-1,1);
				pZ.setGhostWH();
				ev.preventDefault();
				break;
			case 'ArrowDown':
			case 'ArrowLeft':
				pZ.gln=Math.min(pZ.gln+1,100);
				pZ.setGhostWH();
				ev.preventDefault();
				break;
		}
    }
	pZ.showHideGhost=function()
	{
		if(pZ.showGhost) pZ.ghost.classList.add("show");
		else pZ.ghost.classList.remove("show");
	}
	pZ.initGhost=function()
	{
		pZ.gln=20; // largest of ghost width or height in vw unit
		pZ.ghost=document.createElement('figure');
		pZ.ghost.classList.add("ghost");
		pZ.ghost.setAttribute("aria-label",pZ.locale("Model"));
		pZ.ghost.setAttribute("role","img");
		pZ.ghost.setAttribute("tabindex","0");
		// hide the image to screen readers to shorten what they say
		pZ.ghost.append(document.createElement('img'));
		pZ.ghost.firstChild.setAttribute("aria-hidden","true");
		pZ.ghost.firstChild.draggable=false;;
		pZ.ghost.firstChild.src=pZ.imgDataUrl;
		pZ.showHideGhost();
		pZ.board.after(pZ.ghost);
		pZ.ghost.addEventListener('keydown',pZ.resizeGhost);
		pZ.ghost.addEventListener('pointerdown',pZ.dragGhostStart);
		pZ.ghost.addEventListener('pointerup',pZ.dragGhostEnd);
	}
	// puzzle
	pZ.getSvg=function(ev,cls)
	{
		let e=ev.target;
		if(e) return e.closest('svg.'+cls);
		return null;
	}
	pZ.clearRestoreData=function()
	{
		let whmax,pt,emb,th,ms,ro,ric,showsw,showsc,showgh,scatter,bkc,bo;
		let sfls=(p)=>
		{
			let n="pZ_"+p;
			return localStorage[n]?localStorage[n]:pZ.defaultParams[p];
		}
		whmax=sfls("whmax");
		pt=sfls("pt");
		emb=sfls("emb");
		th=sfls("th");
		ms=sfls("ms");
		ro=sfls("ro");
		ric=sfls("ric");
		showsw=sfls("showsw");
		showsc=sfls("showsc");
		showgh=sfls("showgh");
		scatter=sfls("scatter");
		bkc=sfls("bkc");
		bo=sfls("bo");
		localStorage.clear();
		localStorage.pZ_whmax=whmax;
		localStorage.pZ_pt=pt;
		localStorage.pZ_emb=emb;
		localStorage.pZ_th=th;
		localStorage.pZ_ms=ms;
		localStorage.pZ_ro=ro;
		localStorage.pZ_ric=ric;
		localStorage.pZ_showsw=showsw;
		localStorage.pZ_showsc=showsc;
		localStorage.pZ_showgh=showgh;
		localStorage.pZ_scatter=scatter;
		localStorage.pZ_bkc=bkc;
		localStorage.pZ_bo=bo;
	}
	pZ.doGameOver=function()
	{
		pZ.dirty=0;
		if(pZ.selectedArea) pZ.clearSelectedArea();
		if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
		let a=pZ.board.getBoundingClientRect();
		let b=pZ.figcaption.getBoundingClientRect();
		let dX=0,dY=0;
		if(b.left<a.left) dX=a.left-b.left;
		if(b.top<a.top) dY=a.top-b.top;
		if(dX||dY) pZ.board.style.transform="translate("+dX+"px,"+dY+"px)";
		else pZ.board.style.removeProperty("transform");
		pZ.dX=dX;
		pZ.dY=dY;
		pZ.centerFigure();
		pZ.figure.style.removeProperty("background-image");
		pZ.figure.querySelector('.puzzleElement').remove();
		pZ.pauseStopwatch();
		pZ.clearRestoreData();
	}
	pZ.isPuzzleCompleted=function()
	{
		return (pZ.map[0][0].z.length==pZ.w*pZ.h);
	}
	pZ.sendAbove=function(e)
	{
		// do not send e to the end of pZ.figure otherwise multiple side effects
		if(!(pZ.upperLayer&&(pZ.upperLayer==e)))
		{
			pZ.upperLayer=e;
			e.style.setProperty("z-index",++pZ.zIndex);
		}
	}
	pZ.doFocusIn=function(ev)
	{
		// do not always clear pZ.selectedArea here, since one needs it to move items
		let e=pZ.getSvg(ev,"puzzleElement");
		if(!e) return;
		ev.preventDefault();
		ev.stopPropagation();
		if(pZ.noFocusEffect==2) return;
		if(e==pZ.lastFocused) return;
		if(pZ.lastFocused) pZ.lastFocused.classList.remove("lastFocused");
		pZ.lastFocused=e;
		e.classList.add("lastFocused","focusInEffect");
		pZ.sendAbove(e);
		setTimeout(function(){e.classList.remove("focusInEffect");},100)
	}
	pZ.updateMinMax=function(left,top)
	{
		let xmin=pZ.xmin,ymin=pZ.ymin,xmax=pZ.xmax,ymax=pZ.ymax;
		pZ.xmin=Math.min(pZ.xmin,left);
		pZ.xmax=Math.max(pZ.xmax,left+pZ.esz2to);
		pZ.ymin=Math.min(pZ.ymin,top);
		pZ.ymax=Math.max(pZ.ymax,top+pZ.esz2to);
		if((pZ.xmin<xmin)||(pZ.ymin<ymin)||(pZ.xmax>xmax)||(pZ.ymax>ymax))
			pZ.minMaxChange=1;
	}
	pZ.updateEnglued=function(e)
	{
		// detect elements glued on all sides
		// useful for speeding up subsequent gluing
		let bz=e.pZ.m.z;
		for(let m of bz)
		{
			if(!m.englued)
			{
				let c=0;
				if((m.i==0)||bz.includes(pZ.map[m.i-1][m.j])) c|=1;
				if((m.j==0)||bz.includes(pZ.map[m.i][m.j-1])) c|=2;
				if((m.i==(pZ.w-1))||bz.includes(pZ.map[m.i+1][m.j])) c|=4;
				if((m.j==(pZ.h-1))||bz.includes(pZ.map[m.i][m.j+1])) c|=8;
				if(c==15) m.englued=1;
			}
		}
	}
	pZ.gXo=function(svg)
	{
		if(!pZ.rotationOn||!svg.pZ.rotation) return svg.pZ.x;
		let cx,cy;
		cx=(svg.pZ.imax-svg.pZ.imin+1)/2;
		cy=(svg.pZ.jmax-svg.pZ.jmin+1)/2;
		if(svg.pZ.rotation==90) return svg.pZ.x+cx+cy-1;
		if(svg.pZ.rotation==180) return svg.pZ.x+cx+cx-1;
		if(svg.pZ.rotation==270) return svg.pZ.x+cx-cy;
		return svg.pZ.x;
	}
	pZ.gYo=function(svg)
	{
		if(!pZ.rotationOn||!svg.pZ.rotation) return svg.pZ.y;
		cx=(svg.pZ.imax-svg.pZ.imin+1)/2;
		cy=(svg.pZ.jmax-svg.pZ.jmin+1)/2;
		if(svg.pZ.rotation==90) return svg.pZ.y+cy-cx;
		if(svg.pZ.rotation==180) return svg.pZ.y+cy+cy-1;
		if(svg.pZ.rotation==270) return svg.pZ.y+cy+cx-1;
		return svg.pZ.y;
	}
	pZ.gXn=function(svg)
	{
		if(!pZ.rotationOn||!svg.pZ.rotation) return svg.pZ.x+svg.pZ.imax-svg.pZ.imin;
		let cx,cy;
		cx=(svg.pZ.imax-svg.pZ.imin+1)/2;
		cy=(svg.pZ.jmax-svg.pZ.jmin+1)/2;
		if(svg.pZ.rotation==90) return svg.pZ.x+cx+(cy-(svg.pZ.jmax-svg.pZ.jmin))-1;
		if(svg.pZ.rotation==180) return svg.pZ.x+cx+(cx-(svg.pZ.imax-svg.pZ.imin))-1;
		if(svg.pZ.rotation==270) return svg.pZ.x+cx-(cy-(svg.pZ.jmax-svg.pZ.jmin));
		return svg.pZ.x+svg.pZ.imax-svg.pZ.imin+1;
	}
	pZ.gYn=function(svg)
	{
		if(!pZ.rotationOn||!svg.pZ.rotation) return svg.pZ.y+svg.pZ.jmax-svg.pZ.jmin;
		cx=(svg.pZ.imax-svg.pZ.imin+1)/2;
		cy=(svg.pZ.jmax-svg.pZ.jmin+1)/2;
		if(svg.pZ.rotation==90) return svg.pZ.y+cy-(cx-(svg.pZ.imax-svg.pZ.imin));
		if(svg.pZ.rotation==180) return svg.pZ.y+cy+(cy-(svg.pZ.jmax-svg.pZ.jmin))-1;
		if(svg.pZ.rotation==270) return svg.pZ.y+cy+(cx-(svg.pZ.imax-svg.pZ.imin))-1;
		return svg.pZ.y+svg.pZ.jmax-svg.pZ.jmin+1;
	}
	pZ.gX=function(m)
	{
		if(!pZ.rotationOn||!m.svg.pZ.rotation) return m.svg.pZ.x-(m.svg.pZ.imin-m.i);
		let cx,cy;
		cx=(m.svg.pZ.imax-m.svg.pZ.imin+1)/2;
		cy=(m.svg.pZ.jmax-m.svg.pZ.jmin+1)/2;
		if(m.svg.pZ.rotation==90) return m.svg.pZ.x+cx+(cy-(m.j-m.svg.pZ.jmin))-1;
		if(m.svg.pZ.rotation==180) return m.svg.pZ.x+cx+(cx-(m.i-m.svg.pZ.imin))-1;
		if(m.svg.pZ.rotation==270) return m.svg.pZ.x+cx-(cy-(m.j-m.svg.pZ.jmin));
		return m.svg.pZ.x-(m.svg.pZ.imin-m.i);
	}
	pZ.gY=function(m)
	{
		if(!pZ.rotationOn||!m.svg.pZ.rotation) return m.svg.pZ.y-(m.svg.pZ.jmin-m.j);
		cx=(m.svg.pZ.imax-m.svg.pZ.imin+1)/2;
		cy=(m.svg.pZ.jmax-m.svg.pZ.jmin+1)/2;
		if(m.svg.pZ.rotation==90) return m.svg.pZ.y+cy-(cx-(m.i-m.svg.pZ.imin));
		if(m.svg.pZ.rotation==180) return m.svg.pZ.y+cy+(cy-(m.j-m.svg.pZ.jmin))-1;
		if(m.svg.pZ.rotation==270) return m.svg.pZ.y+cy+(cx-(m.i-m.svg.pZ.imin))-1;
		return m.svg.pZ.y-(m.svg.pZ.jmin-m.j);
	}
	pZ.saveElement=function(svg)
	{
		for(let m of svg.pZ.m.z)
		{
			localStorage["l"+m.i+"_"+m.j]=Math.round(pZ.gX(m)*pZ.esz-pZ.to);
			localStorage["t"+m.i+"_"+m.j]=Math.round(pZ.gY(m)*pZ.esz-pZ.to);
			if(pZ.rotationOn) localStorage["r"+m.i+"_"+m.j]=svg.pZ.rotation;
		}
	}
	pZ.perimeter=function(first)
	{
		let next=first,
			border=1,
			d=first.ds.d1,
			p=[{m:first,b:1}];
		let k=0,km=pZ.wh*4; // just to avoid infinite loop when coding error
		do
		{
			let dd="";
			k++;
			if(border==1) // 214
			{
				if((next.i==(pZ.w-1))||(pZ.map[next.i+1][next.j].svg!=next.svg))
				{
					border=2;
					dd=next.ds.d2;
				}
				else if ((next.j==0)
					||(pZ.map[next.i+1][next.j-1].svg!=pZ.map[next.i+1][next.j].svg))
				{
					next=pZ.map[next.i+1][next.j];
					dd=next.ds.d1;
				}
				else
				{
					border=4;
					next=pZ.map[next.i+1][next.j-1];
					dd=next.ds.d4;
				}
			}
			else if(border==2) // 321
			{
				if((next.j==(pZ.h-1))
					||(pZ.map[next.i][next.j+1].svg!=next.svg))
				{
					border=3;
					dd=next.ds.d3;
				}
				else if ((next.i==(pZ.w-1))
					||(pZ.map[next.i+1][next.j+1].svg!=pZ.map[next.i][next.j+1].svg))
				{
					next=pZ.map[next.i][next.j+1];
					dd=next.ds.d2;
				}
				else
				{
					border=1;
					next=pZ.map[next.i+1][next.j+1];
					dd=next.ds.d1;
				}
			}
			else if(border==3) // 432
			{
				if((next.i==0)
					||(pZ.map[next.i-1][next.j].svg!=next.svg))
				{
					border=4;
					dd=next.ds.d4;
				}
				else if ((next.j==(pZ.h-1))
					||(pZ.map[next.i-1][next.j+1].svg!=pZ.map[next.i-1][next.j].svg))
				{
					next=pZ.map[next.i-1][next.j];
					dd=next.ds.d3;
				}
				else
				{
					border=2;
					next=pZ.map[next.i-1][next.j+1];
					dd=next.ds.d2;
				}
			}
			else // 143
			{
				if((next.j==0)||(pZ.map[next.i][next.j-1].svg!=next.svg))
				{
					border=1;
					dd=next.ds.d1;
				}
				else if ((next.i==0)
					||(pZ.map[next.i-1][next.j-1].svg!=pZ.map[next.i][next.j-1].svg))
				{
					next=pZ.map[next.i][next.j-1];
					dd=next.ds.d4;
				}
				else
				{
					border=3;
					next=pZ.map[next.i-1][next.j-1];
					dd=next.ds.d3;
				}
			}
			if(border==1) next.ds.bb|=16;
			if((first==next)&&(border==1)) break; // definition completed
			else
			{
				d+=dd;
				p.push({m:next,b:border});
			}
		} while (k<km);
		return {d:d,p:p};
	}
	pZ.doGluing=function(a)
	{
		if(!(a.ds.bb&15)||a.englued) return;
		function concatZ(a,b){let bz=b.z.concat(a.z);for(let m of bz) m.z=bz;}
		let i=a.i,j=a.j,o=null,ax=pZ.gX(a),ay=pZ.gY(a);
		let t=pZ.threshold/100;
		let dx,dy;
		pZ.updateMinMax(ax*pZ.esz-pZ.to,ay*pZ.esz-pZ.to);
		if((j>0)&&(a.ds.bb&1))
		{
			let b=pZ.map[i][j-1];
			if(pZ.rotationOn)
			{
				if(a.svg.pZ.rotation==90) {dx=1;dy=0;}
				else if(a.svg.pZ.rotation==180) {dx=0;dy=1;}
				else if(a.svg.pZ.rotation==270) {dx=-1;dy=0;}
				else {dx=0;dy=-1;}
			}
			else {dx=0;dy=-1;}
			if(!b.englued
				&&(Math.abs(ax-pZ.gX(b)+dx)<t)
				&&(Math.abs(ay-pZ.gY(b)+dy)<t)
				&&(!pZ.rotationOn||(a.svg.pZ.rotation==b.svg.pZ.rotation))
				&&!b.z.includes(a))
			{
				concatZ(a,b);
				o=b;
			}
		}
		if((i<(pZ.w-1))&&(a.ds.bb&2))
		{
			let b=pZ.map[i+1][j];
			if(pZ.rotationOn)
			{
				if(a.svg.pZ.rotation==90) {dx=0;dy=1;}
				else if(a.svg.pZ.rotation==180) {dx=-1;dy=0;}
				else if(a.svg.pZ.rotation==270) {dx=0;dy=-1;}
				else {dx=1;dy=0;}
			}
			else {dx=1;dy=0;}
			if(!b.englued
				&&(Math.abs(ax-pZ.gX(b)+dx)<t)
				&&(Math.abs(ay-pZ.gY(b)+dy)<t)
				&&(!pZ.rotationOn||(a.svg.pZ.rotation==b.svg.pZ.rotation))
				&&!b.z.includes(a))
			{
				concatZ(a,b);
				o=b;
			}
		}
		if((j<(pZ.h-1))&&(a.ds.bb&4))
		{
			let b=pZ.map[i][j+1];
			if(pZ.rotationOn)
			{
				if(a.svg.pZ.rotation==90) {dx=-1;dy=0;}
				else if(a.svg.pZ.rotation==180) {dx=0;dy=-1;}
				else if(a.svg.pZ.rotation==270) {dx=1;dy=0;}
				else {dx=0;dy=1;}
			}
			else {dx=0;dy=1;}
			if(!b.englued
				&&(Math.abs(ax-pZ.gX(b)+dx)<t)
				&&(Math.abs(ay-pZ.gY(b)+dy)<t)
				&&(!pZ.rotationOn||(a.svg.pZ.rotation==b.svg.pZ.rotation))
				&&!b.z.includes(a))
			{
				concatZ(a,b);
				o=b;
			}
		}
		if((i>0)&&(a.ds.bb&8))
		{
			let b=pZ.map[i-1][j];
			if(pZ.rotationOn)
			{
				if(a.svg.pZ.rotation==90) {dx=0;dy=-1;}
				else if(a.svg.pZ.rotation==180) {dx=1;dy=0;}
				else if(a.svg.pZ.rotation==270) {dx=0;dy=1;}
				else {dx=-1;dy=0;}
			}
			else {dx=-1;dy=0;}
			if(!b.englued
				&&(Math.abs(ax-pZ.gX(b)+dx)<t)
				&&(Math.abs(ay-pZ.gY(b)+dy)<t)
				&&(!pZ.rotationOn||(a.svg.pZ.rotation==b.svg.pZ.rotation))
				&&!b.z.includes(a))
			{
				concatZ(a,b);
				o=b;
			}
		}
		if(o)
		{
			let svgo=o.svg,ox,oy;
			if(pZ.rotationOn&&svgo.pZ.rotation)
			{
				ox=pZ.gX(o);
				oy=pZ.gY(o);
			}
			let svg=a.svg;
			let imin=pZ.w,jmin=pZ.h,imax=0,jmax=0;
			let xo=svgo.pZ.x,
				yo=svgo.pZ.y,
				imino=svgo.pZ.imin,
				jmino=svgo.pZ.jmin;
			for(let m of a.z)
			{
				imin=Math.min(imin,m.i);
				jmin=Math.min(jmin,m.j);
				imax=Math.max(imax,m.i);
				jmax=Math.max(jmax,m.j);
			}
			let w=(imax-imin+1)*pZ.esz+2*pZ.to,h=(jmax-jmin+1)*pZ.esz+2*pZ.to;
			let newX=xo+imin-imino;
			let newY=yo+jmin-jmino;
			svg.pZ.imin=imin;
			svg.pZ.jmin=jmin;
			svg.pZ.imax=imax;
			svg.pZ.jmax=jmax;
			svg.setAttributeNS(null,"viewBox","0 0 "+w+" "+h);
			svg.setAttribute("width",w);
			svg.setAttribute("height",h);
			let d="",c=[],p=[];
			if(pZ.internalBordersOn) for(let m of a.z)
			{
				let roMax=pZ.rotationOn?4:1;
				for(let ro=0;ro<roMax;ro++)
					if(m.imgs[ro])
					{
						m.imgs[ro].setAttributeNS(null,"x",(m.i-imin)*pZ.esz);
						m.imgs[ro].setAttributeNS(null,"y",(m.j-jmin)*pZ.esz);
					}
				let ro2=svg.pZ.rotation?Math.round(svg.pZ.rotation/90):0;
				svg.append(m.imgs[ro2]);
			}
			for(let m of a.z) if(m.svg!=svg){m.svg.remove();m.svg=svg;}
			for(let m of a.z)
			{
				m.ds.bb=0;
				if((m.j==0)||(pZ.map[m.i][m.j-1].svg!=m.svg)) m.ds.bb|=1;
				if((m.i==(pZ.w-1))||(pZ.map[m.i+1][m.j].svg!=m.svg)) m.ds.bb|=2;
				if((m.j==(pZ.h-1))||(pZ.map[m.i][m.j+1].svg!=m.svg)) m.ds.bb|=4;
				if((m.i==0)||(pZ.map[m.i-1][m.j].svg!=m.svg)) m.ds.bb|=8;
			}
			for(let ki=imin;ki<=imax;ki++)
				for(let kj=jmin;kj<=jmax;kj++)
				{
					let m=pZ.map[ki][kj];
					if((svg==m.svg)&&!(m.ds.bb&16)&&(m.ds.bb&1))
					// start at the first piece to the left with an external top border
					{
						let xo,yo,pe=pZ.perimeter(m);
						xo=parseFloat(m.ds.d10.replace(/^m([e0-9.-]+) [e0-9.-]+$/i,"$1"));
						yo=parseFloat(m.ds.d10.replace(/^m[e0-9.-]+ ([e0-9.-]+)$/i,"$1"));
						d+="M"+((ki-imin)*pZ.esz+xo)+" "+((kj-jmin)*pZ.esz+yo)+pe.d+"z";
						p.push({ip:ki-imin,jp:kj-jmin,p:pe.p});
						// must continue in case there are "holes" inside the elements
					}
				}
			for(let kj=jmin;kj<=jmax;kj++)
			{
				if(pZ.map[imin][kj].svg==svg)
				{
					svg.pZ.m=pZ.map[imin][kj]; // leftmost then topmost piece of the svg 
					break;
				}
			}
			// set it (newX,newY) at the very last moment
			// since in case of rotation, one has to recompute pZ.gX(o) and pZ.gY(o)
			svg.pZ.x=newX;
			svg.pZ.y=newY;
			if(pZ.rotationOn&&svg.pZ.rotation)
			{
				// have to adapt (newX,newY)
				newX-=(pZ.gX(o)-ox);
				newY-=(pZ.gY(o)-oy);
				svg.pZ.x=newX;
				svg.pZ.y=newY;
			}
			svg.style.left=newX*pZ.esz-pZ.to+"px";
			svg.style.top=newY*pZ.esz-pZ.to+"px";
			let outline=svg.querySelector('path.outline');
			svg.append(outline);
			outline.setAttributeNS(null,"d",d);
			svg.style.setProperty("clip-path","path('"+d+"')");
			svg.pZ.perimeters=p;
			pZ.updatePuzzleElementLabel(svg);
			let xbp=pZ.to-imin*pZ.esz,ybp=pZ.to-jmin*pZ.esz+pZ.ho;
			if(!pZ.internalBordersOn)
				svg.style.setProperty("background-position",xbp+"px "+ybp+"px");
			pZ.updateEnglued(svg);
		}
	}
	pZ.dragContinue=function(ev)
	{
		if(ev.isPrimary&&pZ.movedPiece&&pZ.movedPiece.hasPointerCapture(ev.pointerId))
		{
			for(let e of pZ.selectedElements)
			{
				let left,top;
				e.pZ.movedPieceX=e.pZ.movedPieceX-pZ.lastClientX+ev.clientX;
				e.pZ.movedPieceY=e.pZ.movedPieceY-pZ.lastClientY+ev.clientY;
				left=(e.pZ.movedPieceX-pZ.figureX)/pZ.rf;
				top=(e.pZ.movedPieceY-pZ.figureY)/pZ.rf;
				if(pZ.rotationOn)
				{
					left-=e.pZ.rotationDeltaX;
					top-=e.pZ.rotationDeltaY;
				}
				e.pZ.x=(left+pZ.to)/pZ.esz;
				e.pZ.y=(top+pZ.to)/pZ.esz;
				e.style.left=left+"px";
				e.style.top=top+"px";
			}
			if(pZ.selectedArea)
			{
				pZ.selectedAreaX=pZ.selectedAreaX-pZ.lastClientX+ev.clientX;
				pZ.selectedAreaY=pZ.selectedAreaY-pZ.lastClientY+ev.clientY;
				pZ.selectedArea.style.left=(pZ.selectedAreaX-pZ.figureX)/pZ.rf+"px";
				pZ.selectedArea.style.top=(pZ.selectedAreaY-pZ.figureY)/pZ.rf+"px";
			}
			pZ.lastClientX=ev.clientX;
			pZ.lastClientY=ev.clientY;
		}
	}
	pZ.dragStart=function(ev)
	{
		if(!ev.isPrimary) return;
		e=pZ.getSvg(ev,"puzzleElement");
		if(!e)
		{
			pZ.clearSelectedArea();
			if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
			return;
		}
		if(!pZ.selectedElements.includes(e))
		{
			pZ.clearSelectedArea();
			if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
			pZ.selectedElements.push(e);
		}
		// some browsers (on touch screen device?) do not give the focus to the element
		// when dragging starts thus one has to put the element on the upper layer manually
		e.addEventListener('pointermove',pZ.dragContinue);
		e.setPointerCapture(ev.pointerId);
		pZ.movedPiece=e;
		pZ.lastClientX=ev.clientX;
		pZ.lastClientY=ev.clientY;
		let bf=pZ.figure.getBoundingClientRect();
		pZ.figureX=bf.x;
		pZ.figureY=bf.y;
		if(pZ.selectedArea)
		{
			let bs=pZ.selectedArea.getBoundingClientRect();
			pZ.selectedAreaX=bs.x;
			pZ.selectedAreaY=bs.y;
		}
		for(let e2 of pZ.selectedElements)
		{
			pZ.sendAbove(e2);
			let be2=e2.getBoundingClientRect();
			e2.pZ.movedPieceX=be2.x;
			e2.pZ.movedPieceY=be2.y;
			if(pZ.rotationOn)
			{
				let top,left,x,y;
				left=(e2.pZ.movedPieceX-pZ.figureX)/pZ.rf,
				top=(e2.pZ.movedPieceY-pZ.figureY)/pZ.rf;
				e2.pZ.rotationDeltaX=left-e2.pZ.x*pZ.esz+pZ.to;
				e2.pZ.rotationDeltaY=top-e2.pZ.y*pZ.esz+pZ.to;
			}
		}
		pZ.sendAbove(e);
		if(pZ.selectedArea) pZ.selectedArea.style.setProperty("z-index",pZ.zIndex);
	}
	pZ.dragEnd=function(ev)
	{
		if(!ev.isPrimary) return;
		let e=pZ.getSvg(ev,"puzzleElement");
		if(!e) return;
		if(e.hasPointerCapture(ev.pointerId)) e.releasePointerCapture(ev.pointerId);
		e.removeEventListener('pointermove',pZ.dragContinue);
		if(e==pZ.movedPiece) pZ.match(pZ.selectedElements);
		else
		{
			pZ.clearSelectedArea();
			if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
		}
		pZ.movedPiece=null;
	}
	pZ.rotate2=function(e)
	{
		if(e.pZ.rotation>=360) e.pZ.rotation=0;
		else if(e.pZ.rotation<0) e.pZ.rotation=270;
		if(!e.pZ.rotation) e.style.removeProperty("transform");
		else e.style.setProperty("transform","rotate("+e.pZ.rotation+"deg)");
		if(pZ.internalBordersOn)
		{
			let ro=e.pZ.rotation?Math.round(e.pZ.rotation/90):0;
			let imgList=e.querySelectorAll('image');
			for(let img of imgList)
			{
				let i=img.pZ.i,j=img.pZ.j;
				if(!pZ.map[i][j].imgs[ro])
				{
					let pA={svg:e,i:i,j:j,d:pZ.map[i][j].ds.d,ro:ro,img:img,visible:1};
					pZ.buildImg2(pA);
				}
				else img.replaceWith(pZ.map[i][j].imgs[ro]);
				for(let ro2=0;ro2<4;ro2++)
				{
					if((ro2!=ro)&&!pZ.map[i][j].imgs[ro2])
					{
						let pA={svg:e,i:i,j:j,d:pZ.map[i][j].ds.d,ro:ro2,img:img,visible:0};
						pZ.buildImg2(pA);
					}
				}
			}
		}
	}
	pZ.rotate=function(e,r)
	{
		if(!e.pZ.rotation) e.pZ.rotation=0; // in case of e.pZ.rotation is undefined
		e.pZ.rotation+=r;
		pZ.rotate2(e);
		pZ.saveElement(e);
	}
	pZ.rotateWhenDblClick=function(ev)
	{
		//if(!ev.isPrimary) return; // does not work for dblclick?
		if(pZ.selectedArea||pZ.hasSomeSelectedByKeyboard)
		{
			ev.preventDefault();
			ev.stopPropagation();
			pZ.clearSelectedArea();
			if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
			return;
		}
		let e=pZ.getSvg(ev,"puzzleElement");
		if(!e) return;
		ev.preventDefault();
		ev.stopPropagation();
		pZ.rotate(e,ev.shiftKey?-90:90);
		pZ.updateMessenger(pZ.locale("Rotation"));
		pZ.match([e]);
	}
	pZ.updatePuzzleElementLabel=function(e)
	{
		let s="",x,y,n;
		// e(x of imin,y of jmin) or e.pZ.m(x of ip,y of jp)?
		x=pZ.r2d(pZ.gXo(e)+1);
		y=pZ.r2d(pZ.gYo(e)+1);
		n=e.pZ.m.z.length;
		s+=n+pZ.locale(" ")+((n>1)?pZ.locale("glued pieces"):pZ.locale("piece"));
		s+=pZ.locale(" on ");
		if(n==1) s+=pZ.locale("(")+x+", "+y+pZ.locale(")");
		else
		{
			let x2=pZ.r2d(pZ.gXn(e)+1);
			let y2=pZ.r2d(pZ.gYn(e)+1);
			s+=pZ.locale("(")+Math.min(x,x2)+", "+Math.min(y,y2)+pZ.locale(")");
			s+=pZ.locale(" to ");
			s+=pZ.locale("(")+Math.max(x,x2)+", "+Math.max(y,y2)+pZ.locale(")");
		}
		e.ariaLabel=pZ.ucFirst(s);
	}
	pZ.forceToReturnToDefault=function()
	{
		localStorage.pZ_whmax=pZ.whmax=pZ.defaultParams.whmax;
		localStorage.pZ_pt=pZ.pt=pZ.defaultParams.pt;
		localStorage.pZ_emb=pZ.emboss=pZ.defaultParams.emb;
		localStorage.pZ_th=pZ.threshold=pZ.defaultParams.th;
		localStorage.pZ_ms=pZ.moveStep=pZ.defaultParams.ms;
		localStorage.pZ_ro=pZ.rotationOn=pZ.defaultParams.ro;
		localStorage.pZ_ric=pZ.roundInitialCoordinates=pZ.defaultParams.ric;
		localStorage.pZ_showsw=pZ.showStopwatch=pZ.defaultParams.showsw;
		localStorage.pZ_showsc=pZ.showScore=pZ.defaultParams.showsc;
		localStorage.pZ_showgh=pZ.showGhost=pZ.defaultParams.showgh;
		localStorage.pZ_scatter=pZ.scatter=pZ.defaultParams.scatter;
		localStorage.pZ_bkc=pZ.bkColor=pZ.defaultParams.bkc;
		localStorage.pZ_bo=pZ.beepOn=pZ.defaultParams.bo;
	}
	pZ.abort=function(t)
	{
		if(pZ.abortSignal) return;
		pZ.abortSignal=1;
		pZ.hideWait();
		if(t)
		{
			pZ.noH2Outline=1;
			pZ.doAlert(pZ.locale("Error"),pZ.locale("Sorry, too long! Please reduce the number of pieces via the \"Preferences\" button!"));
		}
	}
	pZ.terminateInitPuzzle=function()
	{
		let t1 = performance.now(),s=pZ.locale("Puzzle of ")+pZ.w+pZ.locale(" by ")+pZ.h+pZ.locale(" pieces");
		pZ.figcaption=document.createElement('figcaption');
		pZ.figcaption.innerHTML=s;
		pZ.figure.append(pZ.figcaption);
		// suffle puzzle pieces
		// if not, when using tab and tab+shift, the pieces may be in the final order
		// let svgs=Array.from(pZ.figure.querySelectorAll('svg'));
		svgs=pZ.shuffleArray(pZ.svgs);
		for(let svg of svgs) pZ.figure.append(svg);
		pZ.board.append(pZ.figure);
		if(pZ.restoreOn)
		{
			// todo: should glue only what was glued before restoring?
			for(i=0;i<pZ.w;i++)
				for(j=0;j<pZ.h;j++)
					pZ.doGluing(pZ.map[i][j]);
			pZ.restoreOn=0;
			pZ.dirty=1;
		}
		else pZ.dirty=0;
		let svgs2=pZ.figure.querySelectorAll('.puzzleElement');
		for(let svg2 of svgs2)
		{
			if(pZ.rotationOn&&svg2.pZ.rotation) pZ.rotate2(svg2);
			// no need to save the element since it is already in the local storage
			pZ.updatePuzzleElementLabel(svg2);
		}
		pZ.startStopwatch();
		pZ.updateScore();
		pZ.inInit=0;
		if(!document.activeElement||!document.activeElement.closest('.menu'))
			pZ.tabTofirst=1;
		pZ.reframe();
		pZ.hideWait();
		pZ.updateMessenger(s);
		t1 = performance.now();
	}
	pZ.createCn=function(k,dw,dh)
	{
		// safari seems to need integer coordinates
		let cn=document.createElement("canvas");
		cn.width=Math.ceil(dw);
		cn.height=Math.ceil(dh);
		pZ["cn"+k]=cn;
		pZ["cx"+k]=cn.getContext("2d");
	}
	pZ.base64Bmp=function(bmp,dw,dh)
	{
		// bmp is an object of the same kind as those created by createImageBitmap()
		// assume dw and dh are integer
		let cn=document.createElement("canvas"),cx;
		cn.width=dw;
		cn.height=dh;
		cx=cn.getContext("2d");
		cx.drawImage(bmp,0,0,dw,dh);
		return cn.toDataURL("image/webp");
	}
	pZ.base64ImagePortion=function(pA)
	{
		// safari seems to need integer coordinates
		if(pZ.abortSignal) return 0;
		let w=pZ.esz2to;
		let h=pZ.esz2to;
		let r=pZ.rif;
		let sx=Math.floor((pA.i?(pA.i*pZ.esz-pZ.to):0)*r);
		let sy=Math.floor((pA.j?(pA.j*pZ.esz-pZ.to-pZ.ho):0)*r);
		let sWidth=Math.floor((((pA.i==0)||(pA.i==(pZ.w-1)))?w-pZ.to:w)*r);
		let sHeight=Math.floor((((pA.j==0)||(pA.j==(pZ.h-1)))?h-pZ.to-pZ.ho:h)*r);
		let dx=Math.floor(pA.i?0:pZ.to*r);
		let dy=Math.floor(pA.j?0:(pZ.to+pZ.ho)*r);
		let dWidth=sWidth;
		let dHeight=sHeight;
		// do not clip in canvas because it pixelizes!
		pZ.cx1.clearRect(0,0,pZ.cn1.width,pZ.cn1.height);
		// add a background to avoid transparency problems
		pZ.cx1.fillStyle= "#fff";
		pZ.cx1.fillRect(0,0,pZ.cn1.width,pZ.cn1.height);
		pZ.cx1.drawImage(pZ.imgBmp?pZ.imgBmp:pZ.imgObj,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight);
		return pZ.cn1.toDataURL("image/webp");
	}
	pZ.base64Image=function(img,dw,dh)
	{
		// img is an object of the same kind as those created by new Image()
		// safari seems to need integer coordinates
		// work randomly on safari without a setTimeout in pZ.buildImg()?
		if(pZ.abortSignal) return 0;
		pZ.cx2.clearRect(0,0,pZ.cn2.width,pZ.cn2.height);
		pZ.cx2.drawImage(img,0,0,Math.floor(dw),Math.floor(dh));
		return pZ.cn2.toDataURL("image/webp");
	}
	pZ.buildImgHref=function(pA)
	{
		if(pZ.abortSignal) return 0;
		let i=pA.i,j=pA.j,esz2to=pZ.esz2to;
		let svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
		svg.setAttributeNS(null,"viewBox","0 0 "+esz2to+" "+esz2to);
		svg.setAttribute("width",esz2to);
		svg.setAttribute("height",esz2to);
		let g=document.createElementNS('http://www.w3.org/2000/svg','g');
		let filterId="emboss"+i+"_"+j+"_"+pA.ro;
		svg.innerHTML=pZ.embossFilterHtml[pA.ro].replace(/id="emboss"/,"id=\""+filterId+"\"");
		let def,clipPath,clipPathId="clipPath"+i+"_"+j,p;
		defs=document.createElementNS('http://www.w3.org/2000/svg','defs');
		clipPath=document.createElementNS('http://www.w3.org/2000/svg','clipPath');
		clipPath.id=clipPathId;
		p=document.createElementNS('http://www.w3.org/2000/svg','path');
		p.setAttributeNS(null,"d",pA.d);
		clipPath.append(p);
		defs.append(clipPath);
		g.append(defs);
		g.setAttribute("filter","url(#"+filterId+")");
		let img=document.createElementNS('http://www.w3.org/2000/svg','image');
		img.setAttributeNS(null,"x",0);
		img.setAttributeNS(null,"y",0);
		img.setAttribute("width",esz2to);
		img.setAttribute("height",esz2to);
		// has to use data image base64 below since one draws this svg on a canvas later
		let t1=performance.now();
		let imgHref=pZ.base64ImagePortion(pA);
		if(!imgHref) return 0;
		img.setAttributeNS(null,"href",imgHref);
		img.setAttribute("clip-path","url(#"+clipPathId+")");
		g.append(img);
		svg.append(g);
		let data=new XMLSerializer().serializeToString(svg);
		return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
	}
	pZ.buildImg=function(pA)
	{
		if(pZ.abortSignal) return 0;
		const t1=performance.now()-pZ.t0;
		if(!pZ.restoreOn&&(t1>pZ.maxLoadingTime)){pZ.abort(t1);return;}
		let esz2to=pZ.esz2to;
		let elementImg=document.createElementNS('http://www.w3.org/2000/svg','image');
		pZ.map[pA.i][pA.j].imgs=[null,null,null,null];
		pZ.map[pA.i][pA.j].imgs[pA.ro]=elementImg;
		elementImg.setAttributeNS(null,"x",0);
		elementImg.setAttributeNS(null,"y",0);
		elementImg.setAttribute("width",esz2to);
		elementImg.setAttribute("height",esz2to);
		// set "aria-hidden" to "true" otherwise some screen readers
		// (for instance safari+voiceover) may annonce "image" when reading the page
		elementImg.setAttribute("aria-hidden","true");
		// transforming the embossed svg in a bitmap image is decisive for play speed
		let img=new Image();
		img.addEventListener("load",()=>
		{
			// safari seems to need a small delay
			setTimeout(()=>
			{
				let t2=performance.now();
				let imgDataUrl=pZ.base64Image(img,esz2to,esz2to);
				if(!imgDataUrl) return 0;
				elementImg.setAttributeNS(null,"href",imgDataUrl);
				elementImg.pZ={i:pA.i,j:pA.j};
				pA.svg.prepend(elementImg);
				pZ.svgs.push(pA.svg);
				pZ.countCreation++;
				if(pZ.countCreation==pZ.wh) pZ.terminateInitPuzzle();
				else 
				{
					let i1=pA.i,j1=pA.j,i2,j2;
					if(j1==(pZ.h-1)) {i2=i1+1;j2=0;}
					else {i2=i1;j2=j1+1;}
					pZ.initElement(i2,j2,pZ.to,pZ.ho,pZ.hor,pZ.a,pZ.qt,pZ.qa,pZ.qx,pZ.qy);
				}
			},Math.round(Math.max(1,pZ.esz/30)));
		});
		let imgHref=pZ.buildImgHref(pA);
		if(imgHref) img.src=imgHref;
	}
	pZ.buildImg2=function(pA)
	{
		// used only if rotation
		let esz2to=pZ.esz2to;
		let elementImg=document.createElementNS('http://www.w3.org/2000/svg','image');
		pZ.map[pA.i][pA.j].imgs[pA.ro]=elementImg;
		elementImg.setAttributeNS(null,"x",pA.img.getAttributeNS(null,"x"));
		elementImg.setAttributeNS(null,"y",pA.img.getAttributeNS(null,"y"));
		elementImg.setAttribute("width",esz2to);
		elementImg.setAttribute("height",esz2to);
		// set "aria-hidden" to "true" otherwise some screen readers
		// (for instance safari+voiceover) may annonce "image" when reading the page
		elementImg.setAttribute("aria-hidden","true");
		elementImg.pZ={i:pA.i,j:pA.j};
		// transforming the embossed svg in a bitmap image is decisive for play speed
		let img=new Image();
		img.addEventListener("load",()=>
		{
			// safari seems to need a small delay
			setTimeout(()=>
			{
				let imgDataUrl=pZ.base64Image(img,esz2to,esz2to);
				if(!imgDataUrl) return 0;
				elementImg.setAttributeNS(null,"href",imgDataUrl);
				if(pA.visible) pA.img.replaceWith(elementImg);
			},Math.round(Math.max(1,pZ.esz/30)));
		});
		let imgHref=pZ.buildImgHref(pA);
		if(imgHref) img.src=imgHref;
	}
	pZ.pAlea=function(t=0)
	{
		let a=[],fx=pZ.fx,fy=pZ.fy,ft=pZ.ft,fa=pZ.fa;
		for(let i=0;i<pZ.w;i++)
		{
			a[i]=[];
			for(let j=0;j<pZ.h;j++)
			{
				let e=[];
				if(j==0) // top
				{
					if(t=="qx"){if(i==0) e[0]=0; else e[0]=a[i-1][j][1];}
					else e[0]=0;
				}
				else
				{
					if((t=="qx")||(t=="qy")) e[0]=a[i][j-1][3];
					else e[0]=a[i][j-1][2];
				}
				if(i==(pZ.w-1)) // right
				{
					if(t=="qy"){if(j==0) e[1]=0; else e[1]=a[i][j-1][2];}
					else e[1]=0;
				}
				else
				{
					if(t=="qx"){if(j==0) e[1]=pZ.alea(4)*fx-2*fx; else e[1]=a[i][j-1][2];}
					else if(t=="qy"){if(j==0) e[1]=0; else e[1]=a[i][j-1][2];}
					else if(t=="qt") e[1]=pZ.alea(2)*ft-ft;
					else if(t=="qa") e[1]=pZ.alea(2)*fa-fa;
					else e[1]=pZ.alea(1)?1:-1;
				}
				if(j==(pZ.h-1)) // bottom
				{
					if(t=="qx"){if(i==(pZ.w-1)) e[2]=0; else e[2]=pZ.alea(4)*fx-2*fx;}
					else e[2]=0;
				}
				else
				{
					if(t=="qx"){if(i==(pZ.w-1)) e[2]=0; else e[2]=pZ.alea(4)*fx-2*fx;}
					else if(t=="qy") e[2]=pZ.alea(4)*fy-2*fy;
					else if(t=="qt") e[2]=pZ.alea(2)*ft-ft;
					else if(t=="qa") e[2]=pZ.alea(2)*fa-fa;
					else e[2]=pZ.alea(1)?1:-1;
				}
				if(i==0) // left
				{
					if(t=="qy") {if(j==(pZ.h-1)) e[3]=0; else e[3]=pZ.alea(4)*fy-2*fy;}
					else e[3]=0;
				}
				else
				{
					if((t=="qx")||(t=="qy")) e[3]=a[i-1][j][2];
					else e[3]=a[i-1][j][1];
				}
				a[i][j]=e;
			}
		}
		return a;
	};

	pZ.prepareOutsideScattering=function()
	{
		// prepare 2 arrays to help to place pieces on possible coordinates
		// kScatter: array of piece indices (k=j*pZ.w+i) chosen at random
		// pScatter: array of possible coordinates around the central area
		let e,ho;
		e=(pZ.moveStep<=50)?(pZ.moveStep/100):0;
		ho=pZ.roundInitialCoordinates?0:(pZ.ho/pZ.esz);
		pZ.kScatter=[];
		for(let i=0;i<pZ.w;i++)
			for(let j=0;j<pZ.h;j++)
				pZ.kScatter.push(j*pZ.w+i);
		pZ.kScatter=pZ.shuffleArray(pZ.kScatter);
		pZ.pScatter=[];
		for(let i=0;i<pZ.w;i++)
		{
			
			pZ.pScatter.push({i:i,j:-1-e+ho});
			pZ.pScatter.push({i:i,j:pZ.h+e-ho});
		}
		for(let j=0;j<pZ.h;j++)
		{
			pZ.pScatter.push({i:-1-e,j:j});
			pZ.pScatter.push({i:pZ.w+e,j:j});
		}
		pZ.pScatter=pZ.shuffleArray(pZ.pScatter);
		if(pZ.kScatter.length>pZ.pScatter.length)
			pZ.kScatter=pZ.kScatter.slice(0,pZ.pScatter.length);
		else if(pZ.pScatter.length>pZ.kScatter.length)
			pZ.pScatter=pZ.pScatter.slice(0,pZ.kScatter.length);
	}
	pZ.generateTopLeft=function(i,j)
	{
		let left,top,a,b,c,k,ko,po;
		let e=(pZ.moveStep<=50)?pZ.moveStep:0;
		if((pZ.scatter=="outside")&&pZ.kScatter&&pZ.kScatter.length&&pZ.pScatter&&pZ.pScatter.length)
		{
			ko=pZ.kScatter.indexOf(j*pZ.w+i);
			if(ko>-1)
			{
				// add the piece on integer coordinates
				pZ.kScatter.splice(ko,1);
				po=pZ.pScatter.pop();
				left=po.i*100*pZ.esz00-pZ.to;
				top=po.j*100*pZ.esz00-pZ.to;
				return {top:top,left:left};
			}
		}
		if(pZ.roundInitialCoordinates)
		{
			if(pZ.scatter=="inside")
			{
				a=Math.round(pZ.alea((pZ.w-1)*100)/pZ.moveStep);
				b=Math.round(pZ.alea((pZ.h-1)*100)/pZ.moveStep);
			}
			else // scatter around
			{
				c=pZ.alea(3)+1;
				switch(c)
				{
					case 1:
						a=Math.round(pZ.alea((pZ.w-1)*100)/pZ.moveStep);
						b=(-100-e)/pZ.moveStep;
						break;
					case 2:
						a=((100*pZ.w)+e)/pZ.moveStep;
						b=Math.round(pZ.alea((pZ.h-1)*100)/pZ.moveStep);
						break;
					case 3:
						a=Math.round(pZ.alea((pZ.w-1)*100)/pZ.moveStep);
						b=((100*pZ.h)+e)/pZ.moveStep;
						break;
					case 4:
						a=(-100-e)/pZ.moveStep;
						b=Math.round(pZ.alea((pZ.h-1)*100)/pZ.moveStep);
						break;
				}
			}
			left=a*pZ.moveStep*pZ.esz00-pZ.to;
			top=b*pZ.moveStep*pZ.esz00-pZ.to;
		}
		else
		{
			if(pZ.scatter=="inside")
			{
				a=pZ.alea((pZ.w-1)*pZ.esz);
				b=pZ.alea((pZ.h-1)*pZ.esz);
			}
			else // scatter around
			{
				c=pZ.alea(3)+1;
				let ho=pZ.ho;
				switch(c)
				{
					case 1:
						a=pZ.alea((pZ.w-1)*pZ.esz);
						b=(-1-e/100)*pZ.esz+ho;
						break;
					case 2:
						a=(pZ.w+e/100)*pZ.esz;
						b=pZ.alea((pZ.h-1)*pZ.esz);
						break;
					case 3:
						a=pZ.alea((pZ.w-1)*pZ.esz);
						b=(pZ.h+e/100)*pZ.esz-ho;
						break;
					case 4:
						a=(-1-e/100)*pZ.esz;
						b=pZ.alea((pZ.h-1)*pZ.esz);
						break;
				}
			}
			left=a-pZ.to;
			top=b-pZ.to;
		}
		return {top:top,left:left};
	}
	pZ.doScatteringOnly=function()
	{
		if(pZ.scatter=="outside") pZ.prepareOutsideScattering();
		for(let i=0;i<pZ.w;i++)
			for(let j=0;j<pZ.h;j++)
			{
				// consider only element of one piece, let the others in place
				if(pZ.map[i][j].z.length==1)
				{
					let tl=pZ.generateTopLeft(i,j);
					let left=tl.left;
					let top=tl.top;
					localStorage["l"+i+"_"+j]=left;
					localStorage["t"+i+"_"+j]=top;
					let x=(left+pZ.to)/pZ.esz;
					let y=(top+pZ.to)/pZ.esz;
					let svg=pZ.map[i][j].svg;
					svg.style.left=left+"px";
					svg.style.top=top+"px";
					svg.pZ.x=x;
					svg.pZ.y=y;
				}
			}
	}
	pZ.doRotationOnly=function()
	{
		let svgs=pZ.figure.querySelectorAll('.puzzleElement');
		if(pZ.rotationOn)
		{
			pZ.figure.addEventListener('dblclick',pZ.rotateWhenDblClick);
			for(let svg of svgs)
			{
				// no change, just init svg.pZ.rotation and save it in the localStorage
				svg.pZ.rotation=0;
				pZ.saveElement(svg);
			}
		}
		else
		{
			pZ.figure.removeEventListener('dblclick',pZ.rotateWhenDblClick);
			for(let svg of svgs)
			{
				// remove the rotation effect if any,
				// save the change in the localStorage,
				// update the aria-label
				svg.pZ.rotation=0;
				pZ.rotate2(svg);
				pZ.saveElement(svg);
				pZ.updatePuzzleElementLabel(svg);
			}
		}	
	}
	pZ.initElement=function(i,j,to,ho,hor,a,qt,qa,qx,qy)
	{
		if(pZ.abortSignal) return;
		let svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
		let d,d1,d2,d3,d4,d10,d20,d30,d40,left,top,x,y;
		pZ.map[i][j]={svg:svg,i:i,j:j};
		pZ.map[i][j].z=[pZ.map[i][j]];
		svg.pZ={m:pZ.map[i][j]};
		svg.classList.add("puzzleElement");
		svg.pZ.imin=svg.pZ.imax=i;
		svg.pZ.jmin=svg.pZ.jmax=j;
		svg.setAttributeNS(null,"viewBox","0 0 "+pZ.esz2to+" "+pZ.esz2to);
		svg.setAttribute("width",pZ.esz2to);
		svg.setAttribute("height",pZ.esz2to);
		svg.setAttribute("tabindex","0");
		let hoj0=((j==0)?ho:0);
		let hojn=((j==(pZ.h-1))?ho:0);
		let hoo=hoj0+hojn;
		let bRef=6*pZ.esz00;
		let qttRef=pZ.esz00;
		let qxyRef=8*pZ.esz00;
		let anRef=15*pZ.esz00;
		let anDiv=2;
		let qaRef=pZ.esz00;
		let adRef=50*pZ.esz00;
		// desc
		// tmt: tenon or mortise type, mortise (<0) or tenon (>0) or straight (=0)
		// qt: tenon or mortise offset, to begin (<0), to end (>0), centered (=0)
		// qa: tenon or mortise size, small (<0), big (>0) or medium (=0)
		// qx: corner abscissa offset, -2, -1, 0, 1, 2
		// qy: corner ordinate offset, -2, -1, 0, 1, 2
		let desc=[];
		if((pZ.pt=="quirky")||(pZ.pt=="curvy"))
		{
			let kb,kt,kx1,ky1,kx2,ky2,ad,an,af,qtt,qxy1,qxy2,qaa;
			let sl,px1,px2,px3,px4,py1,py2,py3,py4,aaa;
			// top
			qxy1=((j==0)||(j==1)||(j==(pZ.h-1)))?hor*qxyRef:qxyRef;
			kx1=qxy1*qx[i][j][0];
			ky1=qxy1*qy[i][j][0];
			kx2=qxy1*qx[i][j][1];
			ky2=qxy1*qy[i][j][1];
			d10="m"+(to+kx1)+" "+(to+hoj0+ky1);
			d1="";
			if(a[i][j][0])
			{
				qtt=((j==1)||(j==(pZ.h-1)))?hor*qttRef:qttRef;
				kt=qtt*qt[i][j][0];
				kb=a[i][j][0]*bRef;
				qaa=qa[i][j][0]*qaRef;
				an=anRef+qaa+pZ.esz00*(-qx[i][j][0]+qx[i][j][1])/anDiv;
				ad=adRef-an/2;
				af=pZ.esz-2*ad;
				ad=ad-(kx1-kx2)/2;
				sl=(ky2-ky1)/(pZ.esz-kx1+kx2);
				px1=(ad-kt)/2;
				py1=px1*sl-kb;
				px2=ad-kt;
				py2=px2*sl-kb;
				px3=af;
				py3=px3*sl;
				px4=(ad+kt)/2;
				py4=px4*sl;
				px5=ad+kt;
				py5=px5*sl+kb;
				aaa="a"+an+" "+an+((a[i][j][0]>0)?" 0 1 0 ":" 1 1 1 ");
				d1+="q"+px1+" "+py1+" "+px2+" "+py2+aaa+px3+" "+py3+"q"+px4+" "+py4+" "+px5+" "+py5;
			}
			else d1+="h"+(pZ.esz-kx1+kx2);
			desc[0]={tmt:-a[i][j][0],qt:-qt[i][j][0],qa:qa[i][j][0],qx:qx[i][j][1],qy:qy[i][j][1]};

			// right
			qxy1=((j==0)||(j==1)||(j==(pZ.h-1)))?hor*qxyRef:qxyRef;
			qxy2=((j==0)||(j==(pZ.h-2))||(j==(pZ.h-1)))?hor*qxyRef:qxyRef;
			kx1=qxy1*qx[i][j][1];
			ky1=qxy1*qy[i][j][1];
			kx2=qxy2*qx[i][j][2];
			ky2=qxy2*qy[i][j][2];
			d20="m"+(to+pZ.esz+kx1)+" "+(to+hoj0+ky1);
			d2="";
			if(a[i][j][1])
			{
				qtt=((j==0)||(j==(pZ.h-1)))?hor*qttRef:qttRef;
				kt=qtt*qt[i][j][1];
				kb=a[i][j][1]*bRef;
				qaa=qa[i][j][1]*qaRef;
				an=anRef+qaa+pZ.esz00*(-qy[i][j][1]+qy[i][j][2])/anDiv;
				ad=adRef-an/2;
				af=pZ.esz-2*ad;
				ad=ad-(ky1-ky2)/2-hoo/2;
				sl=(kx2-kx1)/(pZ.esz-hoo-ky1+ky2);
				py1=(ad-kt)/2;
				px1=py1*sl+kb;
				py2=ad-kt;
				px2=py2*sl+kb;
				py3=af;
				px3=py3*sl;
				py4=(ad+kt)/2;
				px4=py4*sl;
				py5=ad+kt;
				px5=py5*sl-kb;
				aaa="a"+an+" "+an+((a[i][j][1]>0)?" 0 1 0 ":" 1 1 1 ");
				d2+="q"+px1+" "+py1+" "+px2+" "+py2+aaa+px3+" "+py3+"q"+px4+" "+py4+" "+px5+" "+py5;
			}
			else d2+="v"+(pZ.esz-hoo-ky1+ky2);
			desc[1]={tmt:-a[i][j][1],qt:-qt[i][j][1],qa:qa[i][j][1],qx:qx[i][j][2],qy:qy[i][j][2]};
			
			// bottom
			qxy1=((j==0)||(j==(pZ.h-2))||(j==(pZ.h-1)))?hor*qxyRef:qxyRef;
			kx1=qxy1*qx[i][j][2];
			ky1=qxy1*qy[i][j][2];
			kx2=qxy1*qx[i][j][3];
			ky2=qxy1*qy[i][j][3];
			d30="m"+(to+pZ.esz+kx1)+" "+(to+hoj0+pZ.esz-hoo+ky1);
			d3="";
			if(a[i][j][2])
			{
				qtt=((j==0)||(j==(pZ.h-2)))?hor*qttRef:qttRef;
				kt=qtt*qt[i][j][2];
				kb=a[i][j][2]*bRef;
				qaa=qa[i][j][2]*qaRef;
				an=anRef+qaa+pZ.esz00*(qx[i][j][2]-qx[i][j][3])/anDiv;
				ad=adRef-an/2;
				af=pZ.esz-2*ad;
				ad=ad+(kx1-kx2)/2;
				sl=(ky2-ky1)/(-pZ.esz-kx1+kx2);
				px1=(-ad-kt)/2;
				py1=px1*sl-kb;
				px2=-ad-kt;
				py2=px2*sl-kb;
				px3=-af;
				py3=px3*sl;
				px4=(-ad+kt)/2;
				py4=px4*sl;
				px5=-ad+kt;
				py5=px5*sl+kb;
				aaa="a"+an+" "+an+((a[i][j][2]>0)?" 1 1 1 ":" 0 1 0 ");
				d3+="q"+px1+" "+py1+" "+px2+" "+py2+aaa+px3+" "+py3+"q"+px4+" "+py4+" "+px5+" "+py5;
			}
			else d3+="h"+(-pZ.esz-kx1+kx2);
			desc[2]={tmt:a[i][j][2],qt:qt[i][j][2],qa:qa[i][j][2],qx:qx[i][j][3],qy:qy[i][j][3]};
			
			// left
			qxy1=((j==0)||(j==(pZ.h-2))||(j==(pZ.h-1)))?hor*qxyRef:qxyRef;
			qxy2=((j==0)||(j==1)||(j==(pZ.h-1)))?hor*qxyRef:qxyRef;
			kx1=qxy1*qx[i][j][3];
			ky1=qxy1*qy[i][j][3];
			kx2=qxy2*qx[i][j][0];
			ky2=qxy2*qy[i][j][0];
			d40="m"+(to+kx1)+" "+(to+hoj0+pZ.esz-hoo+ky1);					
			d4="";
			if(a[i][j][3])
			{
				qtt=((j==0)||(j==(pZ.h-1)))?hor*qttRef:qttRef;
				kt=qtt*qt[i][j][3];
				kb=a[i][j][3]*bRef;
				qaa=qa[i][j][3]*qaRef;
				an=anRef+qaa+pZ.esz00*(qy[i][j][3]-qy[i][j][0])/anDiv;
				ad=adRef-an/2;
				af=pZ.esz-2*ad;
				ad=ad+(ky1-ky2)/2-hoo/2;
				sl=(kx2-kx1)/(-pZ.esz+hoo-ky1+ky2);
				py1=(-ad-kt)/2;
				px1=py1*sl+kb;
				py2=-ad-kt;
				px2=py2*sl+kb;
				py3=-af;
				px3=py3*sl;
				py4=(-ad+kt)/2;
				px4=py4*sl;
				py5=-ad+kt;
				px5=py5*sl-kb;
				aaa="a"+an+" "+an+((a[i][j][3]>0)?" 1 1 1 ":" 0 1 0 ");
				d4+="q"+px1+" "+py1+" "+px2+" "+py2+aaa+px3+" "+py3+"q"+px4+" "+py4+" "+px5+" "+py5;
			}
			else d4+="v"+(-pZ.esz+hoo-ky1+ky2);
			desc[3]={tmt:a[i][j][3],qt:qt[i][j][3],qa:qa[i][j][3],qx:qx[i][j][0],qy:qy[i][j][0]};
		}
		else // squared
		{
			let mesz=25*pZ.esz00,mesz2=(pZ.esz-mesz)/2;
			d10="m"+to+" "+(to+hoj0);
			d20="m"+(to+pZ.esz)+" "+(to+hoj0);
			d30="m"+(to+pZ.esz)+" "+(to+hoj0+pZ.esz-hoo);
			d40="m"+to+" "+(to+hoj0+pZ.esz-hoo);
			d1="h"+mesz2+"v"+(mesz*a[i][j][0])+"h"+mesz+"v"+(-mesz*a[i][j][0])+"h"+mesz2;
			desc[0]={tmt:a[i][j][0]};
			d2="v"+(mesz2-hoo/2)+"h"+(mesz*a[i][j][1])+"v"+mesz+"h"+(-mesz*a[i][j][1])+"v"+(mesz2-hoo/2);
			desc[1]={tmt:a[i][j][1]};
			d3="h-"+mesz2+"v"+(mesz*a[i][j][2])+"h-"+mesz+"v"+(-mesz*a[i][j][2])+"h-"+mesz2;
			desc[2]={tmt:a[i][j][2]};
			d4="v"+(-(mesz2-hoo/2))+"h"+(mesz*a[i][j][3])+"v-"+mesz+"h"+(-mesz*a[i][j][3])+"v"+(-(mesz2-hoo/2));
			desc[3]={tmt:a[i][j][3]};
		}
		d=d10+d1+d2+d3+d4+"z";
		if((pZ.restoreOn>0)&&(pZ.restoreOn<8)&&localStorage["l"+i+"_"+j]&&localStorage["t"+i+"_"+j])
		{
			left=-(-localStorage["l"+i+"_"+j]);
			top=-(-localStorage["t"+i+"_"+j]);
		}
		else
		{
			let tl=pZ.generateTopLeft(i,j);
			left=tl.left;
			top=tl.top;
			localStorage["l"+i+"_"+j]=left;
			localStorage["t"+i+"_"+j]=top;
		}
		x=(left+to)/pZ.esz;
		y=(top+to)/pZ.esz;
		svg.style.left=left+"px";
		svg.style.top=top+"px";
		svg.pZ.x=x;
		svg.pZ.y=y;
		if(pZ.rotationOn)
		{
			if(!pZ.restoreOn||(pZ.restoreOn&16))
				localStorage["r"+i+"_"+j]=svg.pZ.rotation=pZ.alea(3)*90;
			else
			{
				if(!localStorage["r"+i+"_"+j]) svg.pZ.rotation=0;
				else svg.pZ.rotation=-(-localStorage["r"+i+"_"+j]);
			}
		}
		if(!pZ.internalBordersOn)
		{
			svg.style.backgroundSize=(pZ.w*pZ.esz)+"px auto";
			svg.style.backgroundPosition=(to-i*pZ.esz)+"px "+(to-j*pZ.esz+ho)+"px";
			svg.style.backgroundRepeat="no-repeat";
			// Safari seems to need a fake element covering all the svg to make clip working conveniently
			// otherwise, coordinates of the clipping area are wrong
			let rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
			rect.setAttributeNS(null,"width","100%");
			rect.setAttributeNS(null,"height","100%");
			rect.setAttributeNS(null,"fill","#0000");
			svg.append(rect);
		}
		let outline=document.createElementNS('http://www.w3.org/2000/svg','path');
		outline.setAttributeNS(null,"d",d);
		outline.classList.add("outline");
		svg.append(outline);
		svg.style.setProperty("clip-path","path('"+d+"')");
		svg.pZ.perimeters=[{ip:0,jp:0,p:[{m:pZ.map[i][j],b:1},{m:pZ.map[i][j],b:2},{m:pZ.map[i][j],b:3},{m:pZ.map[i][j],b:4}]}];
		pZ.map[i][j].ds={d:d,d10:d10,d20:d20,d30:d30,d40:d40,d1:d1,d2:d2,d3:d3,d4:d4,bb:15,desc:desc};
		pZ.updateMinMax(left,top);
		pZ.updatePuzzleElementLabel(svg);
		if(pZ.internalBordersOn) pZ.buildImg({svg:svg,i:i,j:j,d:d,ro:svg.pZ.rotation?Math.round(svg.pZ.rotation/90):0});
		else
		{
			const t1 = performance.now()-pZ.t0;
			if(!pZ.restoreOn&&(t1>pZ.maxLoadingTime/10)){pZ.abort(t1);return;}// 10 times less than when embossing?
			svg.append(outline);
			pZ.svgs.push(svg);
			if(pZ.rotationOn&&svg.pZ.rotation) pZ.rotate2(svg);
			pZ.countCreation++;
			if(pZ.countCreation==pZ.wh) pZ.terminateInitPuzzle();
		}
	}
	pZ.clearFigure=function()
	{
		pZ.inInit=1;
		pZ.abortSignal=0;
		if(pZ.figure)
		{
			pZ.upperLayer=null;
			pZ.figure.remove();
			pZ.figure=null;
		}
	}
	pZ.initPuzzle=function()
	{
		pZ.t0=performance.now();
		if(pZ.setTimeoutId) clearTimeout(pZ.setTimeoutId);
		// do not save too large imgDataUrl, as localStorage capacity is limited
		// in practice, should not happen if pZ.iwhMax<=1280
		if(pZ.imgDataUrl.length<4000001) localStorage.imgDataUrl=pZ.imgDataUrl;
		pZ.clearFigure();
		pZ.lastFocused=null;
		pZ.computeWH();
		pZ.internalBordersOn=pZ.emboss?1:0;
		pZ.embossFilterHtml=pZ.makeEmbossFilter();
		pZ.esz=pZ.computeEsz();
		pZ.to=pZ.esz/2;
		pZ.esz2to=pZ.esz+2*pZ.to;
		pZ.esz00=pZ.esz/100;
		document.body.style.setProperty("--esz00",pZ.esz00);
		pZ.ho=pZ.esz*(pZ.h-pZ.w*pZ.ih/pZ.iw)/2;
		pZ.hor=(1-pZ.ho/pZ.esz)*(1-pZ.ho/pZ.esz);
		pZ.initScrollArea();
		pZ.clearSelectedArea();
		if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
		pZ.setGhostWH();
		pZ.zIndex=0;
		let to=pZ.to; // magic offset to keep room for tenon and piece deformation
		let ho=pZ.ho; // magic h offset when the image and puzzle ratio are not the same
		let hor=pZ.hor; // magic coefficient to reduce edge piece deformation
		if(pZ.scatter=="outside") pZ.prepareOutsideScattering();
		pZ.fb=((pZ.pt=="curvy")||(pZ.pt=="quirky"))?1:0; // curve
		pZ.ft=(pZ.pt=="quirky")?1:0; // tenon offset
		pZ.fa=(pZ.pt=="quirky")?1:0; // tenon radius
		pZ.fx=pZ.fy=(pZ.pt=="quirky")?1:0; // corner position
		let a,qt,qa,qx,qy;
		// pZ.restoreOn cannot be exactly 8 here
		if((pZ.restoreOn>0)&&(pZ.restoreOn<4)
			&&localStorage.a
			&&localStorage.qt
			&&localStorage.qa
			&&localStorage.qx
			&&localStorage.qy)
		{
			// when restore dialog appearing or when changing emboss, piece shape, scattering
			a=JSON.parse(localStorage.a);
			qt=JSON.parse(localStorage.qt);
			qa=JSON.parse(localStorage.qa);
			qx=JSON.parse(localStorage.qx);
			qy=JSON.parse(localStorage.qy);
		}
		else
		{
			a=pZ.pAlea("a"), // tenon or mortise
			localStorage.a=JSON.stringify(a);
			qt=pZ.pAlea("qt"), // tenon translation
			localStorage.qt=JSON.stringify(qt);
			qa=pZ.pAlea("qa"), // tenon radius
			localStorage.qa=JSON.stringify(qa);
			qx=pZ.pAlea("qx"), // corner offset x coordinate
			localStorage.qx=JSON.stringify(qx);
			qy=pZ.pAlea("qy"); // corner offset y coordinate
			localStorage.qy=JSON.stringify(qy);
		}
		pZ.a=a;
		pZ.qt=qt;
		pZ.qa=qa;
		pZ.qx=qx;
		pZ.qy=qy;
		pZ.countCreation=0;
		pZ.figure=document.createElement('figure');
		pZ.figure.classList.add('figure');
		if(!pZ.internalBordersOn) pZ.figure.classList.add('noBorders');
		pZ.figure.style.width=(pZ.esz*pZ.w)+"px";
		pZ.figure.style.height=(pZ.esz*pZ.h)+"px";
		pZ.figure.addEventListener('pointerdown',pZ.dragStart);
		pZ.figure.addEventListener('pointerup',pZ.dragEnd);
		pZ.figure.addEventListener('focusin',pZ.doFocusIn);
		if(pZ.rotationOn) pZ.figure.addEventListener('dblclick',pZ.rotateWhenDblClick);
		// use a linear gradient as background-image
		// to handle the case of top and bottom lines with unusual height
		// this background is the grey rectangle that fits to the puzzle size
		pZ.figure.style.setProperty("background-image","linear-gradient(#0000 0 "+ho+"px,#ccc3 "+ho+"px "+(pZ.esz*pZ.h-ho)+"px,#0000 "+(pZ.esz*pZ.h-ho)+"px "+(pZ.esz*pZ.h)+"px)");
		pZ.map=[];
		for(let i=0;i<pZ.w;i++) pZ.map[i]=[];
		pZ.svgs=[];
		pZ.xmin=-to;
		pZ.xmax=pZ.w*pZ.esz+to;
		pZ.ymin=-to;
		pZ.ymax=pZ.h*pZ.esz+to;
		pZ.rif=pZ.iw/(pZ.esz*pZ.w);
		// faster to create cn and cx only once instead of doing it for each element
		// better for browser memory management?
		pZ.createCn(1,pZ.esz2to*pZ.rif,pZ.esz2to*pZ.rif);
		pZ.createCn(2,pZ.esz2to,pZ.esz2to);
		if(pZ.internalBordersOn) pZ.initElement(0,0,to,ho,hor,a,qt,qa,qx,qy);
		else for(let i=0;i<pZ.w;i++)
			for(let j=0;j<pZ.h;j++)
			{
				if(pZ.abortSignal) return;
				pZ.initElement(i,j,to,ho,hor,a,qt,qa,qx,qy);
			}
	}
	// keydown
	pZ.focus=function(e)
	{
		// if e is nearly in its final place, just center the figure
		// else let the browser decides
		if((Math.abs(e.pZ.x-e.pZ.imin)<1.05)&&(Math.abs(e.pZ.y-e.pZ.jmin)<1.05))
		{
			e.focus({preventScroll:true});
			pZ.centerFigure();
		}
		else
		{
			e.focus();
			e.scrollIntoView({block:"nearest",inline:"nearest"});
		}
	}
	pZ.focusOnFirst=function()
	{
		let list=pZ.figure.querySelectorAll('.puzzleElement');
		if(list.length>0) pZ.focus(list[0]);
	}
	pZ.focusOnLast=function()
	{
		let list=pZ.figure.querySelectorAll('.puzzleElement');
		if(list.length>0) pZ.focus(list[list.length-1]);
	}
	pZ.focusOnNextOrFirst=function()
	{
		let a=document.activeElement;
		if(a.classList.contains("puzzleElement"))
		{
			let list=pZ.figure.querySelectorAll('.puzzleElement'),
				k; // k must be declared here since it is used outside the loop
			for(k=0;k<list.length;k++) if(list[k]==a) break;
			if(k>=list.length-1) pZ.focusOnFirst();
			else pZ.focus(list[k+1]);
		}
		else pZ.focusOnFirst();
	}
	pZ.focusOnPredOrLast=function()
	{
		let a=document.activeElement;
		if(a.classList.contains("puzzleElement"))
		{
			let list=pZ.figure.querySelectorAll('.puzzleElement'),
				k; // k must be declared here since it is used outside the loop
			for(k=list.length-1;k>=0;k--) if(list[k]==a) break;
			if(k<1) pZ.focusOnLast();
			else pZ.focus(list[k-1]);
		}
		else pZ.focusOnLast();
	}
	pZ.match=function(eList)
	{
		pZ.dirty=1;
		pZ.minMaxChange=0;
		for(let e of eList)
		{
			let mo=e.pZ.m.z[0];
			// when e.pZ.m.z is changed in doGluing(), z is a new array
			// so e.pZ.m.z in for(let m of e.pZ.m.z) continues to refer to the old z
			for(let m of e.pZ.m.z) pZ.doGluing(m);
			pZ.saveElement(mo.svg);
			pZ.updatePuzzleElementLabel(mo.svg);
		}
		if(pZ.isPuzzleCompleted())
		{
			pZ.doGameOver();
			pZ.updateScore(); // after pZ.doGameOver()
		}
		else
		{
			pZ.updateScore(); // before pZ.adaptScrollArea()
			if(pZ.minMaxChange||pZ.selectedArea) pZ.adaptScrollArea();
		}
	}
	pZ.doBoard=function(ev)
	{
		pZ.clearSelectedArea();
		if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
		let e=document.activeElement;
		if(e?.classList?.contains("puzzleElement"))
		{
			if(ev.shiftKey) pZ.focusOnPredOrLast();
			else pZ.focusOnNextOrFirst();
		}
		else if(pZ.lastFocused) pZ.focus(pZ.lastFocused);
		else pZ.focusOnFirst();
	}
	pZ.edgeShortDesc=function(tmType)
	{
		return (tmType>0)?pZ.locale("tenon"):(tmType<0)?pZ.locale("mortise"):pZ.locale("straight");
	}
	pZ.edgeLongDesc=function(tmType,tmSize,tmOffset,upstream,downstream)
	{
		let s="";
		let tmLabel=(tmType>0)?"tenon":(tmType<0)?"mortise":"straight";
		if(tmType==0) return pZ.locale(tmLabel);
		if(tmSize>0) s+=pZ.locale("big "+tmLabel);
		else if(tmSize==0) s+=pZ.locale("medium "+tmLabel);
		else s+=pZ.locale("small "+tmLabel);
		s+=pZ.locale(", ");
		if(tmOffset>0) s+=pZ.locale("offset to ")+pZ.locale("the "+downstream);
		else if(tmOffset==0) s+=pZ.locale("centered");
		else s+=pZ.locale("offset to ")+pZ.locale("the "+upstream);
		return s;
	}
	pZ.pointDesc=function(r,qx,qy)
	{
		let s="",north,east,south,west;
		switch(r)
		{
			case 1:north="east";east="south";south="west";west="north";break;
			case 2:north="south";east="west";south="north";west="east";break;
			case 3:north="west";east="north";south="east";west="south";break;
			default:north="north";east="east";south="south";west="west";
		}
		switch(qx)
		{
			case -2:s+=pZ.locale("very far to ")+pZ.locale("the "+west);break;
			case -1:s+=pZ.locale("slightly to ")+pZ.locale("the "+west);break;
			case 1:s+=pZ.locale("slightly to ")+pZ.locale("the "+east);break;
			case 2:s+=pZ.locale("very far to ")+pZ.locale("the "+east);break;
		}
		if(s&&qy) s+=pZ.locale(", ");
		switch(qy)
		{
			case -2:s+=pZ.locale("very far to ")+pZ.locale("the "+north);break;
			case -1:s+=pZ.locale("slightly to ")+pZ.locale("the "+north);break;
			case 1:s+=pZ.locale("slightly to ")+pZ.locale("the "+south);break;
			case 2:s+=pZ.locale("very far to ")+pZ.locale("the "+south);break;
		}
		if(!s) s+=pZ.locale("centered");
		return s;
	}
	pZ.doOneElementDescription=function(e,longDescOn)
	{
		let s=e.ariaLabel;
		let r=e.pZ.rotation?Math.round(e.pZ.rotation/90):0;
		function isOnCompletedStraight(p)
		{
			// check if p is on a "completed straight" border
			// if yes
			//   if p is the first on this border
			//     display "xxx edge completed" (iocs=2)
			//     else skip p (iocs=1)
			// else describe p (iocs=0)
			let ip=p.m.i,jp=p.m.j;
			let svg=p.m.svg,found=0;
			switch(p.b)
			{
				case 1:
					if(jp!=0) return 0;
					for(let i=0;i<pZ.w;i++) if(pZ.map[i][0].svg!=svg) {found=1;break;}
					if(found) return 0;
					if((p.m.i==0)&&(p.m.j==0)) return 2;
					return 1;
				case 2:
					if(ip!=(pZ.w-1)) return 0;
					for(let j=0;j<pZ.h;j++) if(pZ.map[pZ.w-1][j].svg!=svg) {found=1;break;}
					if(found) return 0;
					if((p.m.i==(pZ.w-1))&&(p.m.j==0)) return 2;
					return 1;
				case 3:
					if(jp!=(pZ.h-1)) return 0;
					for(let i=0;i<pZ.w;i++) if(pZ.map[i][pZ.h-1].svg!=svg) {found=1;break;}
					if(found) return 0;
					if((p.m.i==(pZ.w-1))&&(p.m.j==(pZ.h-1))) return 2;
					return 1;
				case 4:
					if(ip!=0) return 0;
					for(let j=0;j<pZ.h;j++) if(pZ.map[0][j].svg!=svg) {found=1;break;}
					if(found) return 0;
					if((p.m.i==0)&&(p.m.j==(pZ.h-1))) return 2;
					return 1;
			}
			return 0;
		}
		let first=1;
		for(let perimeter of e.pZ.perimeters)
		{
			let isExternal=1;
			if(!((e.pZ.perimeters.length==1)&&!perimeter.ip&&!perimeter.jp))
			{
				s+=pZ.locale(", ");
				if(first) {s+=pZ.locale("external perimeter starting at ");first=0;}
				else
				{
					isExternal=0;
					s+=pZ.locale("internal perimeter starting at ");
				}
				let mp=pZ.map[e.pZ.imin+perimeter.ip][e.pZ.jmin+perimeter.jp];
				let xp=pZ.r2d(pZ.gX(mp)+1);
				let yp=pZ.r2d(pZ.gY(mp)+1);
				s+=pZ.locale("(")+xp+", "+yp+pZ.locale(")");
			}
			for(let p of perimeter.p)
			{
				let b=((p.b-1)+r)%4;
				let desc=p.m.ds.desc[p.b-1];
				let tmType=desc.tmt;
				let tmSize=desc.qa;
				let tmOffset=desc.qt;
				let iocs=isExternal?isOnCompletedStraight(p):0;
				if(iocs==2)
				{
					s+=pZ.locale(", ");
					switch(b)
					{
						case 0:
							s+=pZ.locale("north edge");
							s+=pZ.locale(", ");
							s+=pZ.locale("straight, completed");
							break;
						case 1:
							s+=pZ.locale("east edge");
							s+=pZ.locale(", ");
							s+=pZ.locale("straight, completed");
							break;
						case 2:
							s+=pZ.locale("south edge");
							s+=pZ.locale(", ");
							s+=pZ.locale("straight, completed");
							break;
						case 3:
							s+=pZ.locale("west edge");
							s+=pZ.locale(", ");
							s+=pZ.locale("straight, completed");
							break;
					}
				}
				// else if(iocs==1), just skip
				else if(iocs==0)
				{
					s+=pZ.locale(", ");
					switch(b)
					{
						
						case 0:
							s+=pZ.locale("north edge");
							s+=pZ.locale(", ");
							if(longDescOn)
							{
								s+=pZ.edgeLongDesc(tmType,tmSize,tmOffset,"west","east");
								s+=pZ.locale(", ");
								s+=pZ.locale("northeast point");
							}
							else s+=pZ.edgeShortDesc(tmType);
							break;
						case 1:
							s+=pZ.locale("east edge");
							s+=pZ.locale(", ");
							if(longDescOn)
							{
								s+=pZ.edgeLongDesc(tmType,tmSize,tmOffset,"north","south");
								s+=pZ.locale(", ");
								s+=pZ.locale("southeast point");
							}
							else s+=pZ.edgeShortDesc(tmType);
							break;
						case 2:
							s+=pZ.locale("south edge");
							s+=pZ.locale(", ");
							if(longDescOn)
							{
								s+=pZ.edgeLongDesc(tmType,tmSize,tmOffset,"east","west");
								s+=pZ.locale(", ");
								s+=pZ.locale("southwest point");
							}
							else s+=pZ.edgeShortDesc(tmType);
							break;
						case 3:
							s+=pZ.locale("west edge");
							s+=pZ.locale(", ");
							if(longDescOn)
							{
								s+=pZ.edgeLongDesc(tmType,tmSize,tmOffset,"south","north");
								s+=pZ.locale(", ");
								s+=pZ.locale("northwest point");
							}
							else s+=pZ.edgeShortDesc(tmType);
							break;
					}
					if(longDescOn)
					{
						s+=pZ.locale(", ");
						s+=pZ.pointDesc(r,desc.qx,desc.qy);
					}
				}
			}
		}
		return s;
	}
	pZ.doOnePieceDescription=function(m,xm,ym,longDescOn)
	{
		let s;
		s=pZ.locale(", ")+pZ.locale("piece at ")+pZ.locale("(")+xm+", "+ym+pZ.locale(")");
		let svg=m.svg;
		let r=svg.pZ.rotation?Math.round(svg.pZ.rotation/90):0;
		for(let bb of [1,2,3,4])
		{
			let b=((bb-1)+r)%4;
			let desc=m.ds.desc[bb-1];
			let tmType=desc.tmt;
			let tmSize=desc.qa;
			let tmOffset=desc.qt;
			let alreadyGlued=!(m.ds.bb&(1<<(bb-1)));
			s+=pZ.locale(", ");
			switch(b)
			{
				case 0:
					s+=pZ.locale("north edge");
					if(alreadyGlued) s+=pZ.locale(" ")+pZ.locale("already glued");
					s+=pZ.locale(", ");
					if(longDescOn)
					{
						s+=pZ.edgeLongDesc(tmType,tmSize,tmOffset,"west","east");
						s+=pZ.locale(", ");
						s+=pZ.locale("northeast point");
					}
					else s+=pZ.edgeShortDesc(tmType);
					break;
				case 1:
					s+=pZ.locale("east edge");
					if(alreadyGlued) s+=pZ.locale(" ")+pZ.locale("already glued");
					s+=pZ.locale(", ");
					if(longDescOn)
					{
						s+=pZ.edgeLongDesc(tmType,tmSize,tmOffset,"north","south");
						s+=pZ.locale(", ");
						s+=pZ.locale("southeast point");
					}
					else s+=pZ.edgeShortDesc(tmType);
					break;
				case 2:
					s+=pZ.locale("south edge");
					if(alreadyGlued) s+=pZ.locale(" ")+pZ.locale("already glued");
					s+=pZ.locale(", ");
					if(longDescOn)
					{
						s+=pZ.edgeLongDesc(tmType,tmSize,tmOffset,"east","west");
						s+=pZ.locale(", ");
						s+=pZ.locale("southwest point");
					}
					else s+=pZ.edgeShortDesc(tmType);
					break;
				case 3:
					s+=pZ.locale("west edge");
					if(alreadyGlued) s+=pZ.locale(" ")+pZ.locale("already glued");
					s+=pZ.locale(", ");
					if(longDescOn)
					{
						s+=pZ.edgeLongDesc(tmType,tmSize,tmOffset,"south","north");
						s+=pZ.locale(", ");
						s+=pZ.locale("northwest point");
					}
					else s+=pZ.edgeShortDesc(tmType);
					break;
			}
			if(longDescOn)
			{
				s+=pZ.locale(", ");
				s+=pZ.pointDesc(r,desc.qx,desc.qy);
			}
		}
		return s;
	}
	pZ.doDescriptionOfSelectedArea=function(longDescOn)
	{
		let s="";
		let bs=pZ.selectedArea.getBoundingClientRect();
		let bf=pZ.figure.getBoundingClientRect();
		let xs,ys,xls,yts,xrs,ybs,ws,hs;
		xs=(bs.left-bf.left)/pZ.rf;
		ys=(bs.top-bf.top)/pZ.rf;
		ws=bs.width/pZ.rf;
		hs=bs.height/pZ.rf;
		s+=pZ.locale("Selection area at ");
		s+=pZ.locale("(")+pZ.a2A(xs)+pZ.locale(", ")+pZ.a2A(ys)+pZ.locale(")");
		s+=pZ.locale(", ")+pZ.locale("width: ")+pZ.b2B(ws);
		s+=pZ.locale(", ")+pZ.locale("height: ")+pZ.b2B(hs);
		let eList=[];
		for(let e of pZ.figure.querySelectorAll(".puzzleElement"))
		{
			// get all elements that partially intersect with the selected area
			let be=e.querySelector('.outline').getBoundingClientRect();
			if((be.left<(bs.right+1))
				&&(be.right>(bs.left-1))
				&&(be.top<(bs.bottom+1))
				&&(be.bottom>(bs.top-1)))
				eList.push(e);
		}
		// get all path segments that are inside the selected area
		let to00=pZ.to/pZ.esz;
		xls=pZ.a2A(xs)-to00-1;
		yts=pZ.a2A(ys)-to00-1;
		xrs=xls+(pZ.b2B(ws)-1)+2*to00;
		ybs=yts+(pZ.b2B(hs)-1)+2*to00;
		let eList2=[];
		for(let e of eList)
		{
			for(let m of e.pZ.m.z)
			{
				let xm=pZ.gX(m),ym=pZ.gY(m);
				if((xm>=xls)&&(ym>=yts)&&(xm<=xrs)&&(ym<=ybs))
					eList2.push({m:m,xm:xm,ym:ym});
			}
		}
		function compare(a,b)
		{
			if(a.ym!=b.ym) return a.ym-b.ym;
			return a.xm-b.xm;
		}
		eList2.sort(compare);
		for(let e of eList2)
			s+=pZ.doOnePieceDescription(e.m,pZ.r2d(e.xm+1),pZ.r2d(e.ym+1),longDescOn);
		pZ.updateMessenger(s);
	}
	pZ.doDescription=function(ev,e)
	{
		let longDescOn=ev.shiftKey&&(pZ.pt=="quirky");
		if(pZ.selectedArea) pZ.doDescriptionOfSelectedArea(longDescOn);
		else if(pZ.figure)
		{
			// when the description starts with a edge which is not a north one
			// the user can guess that there is a rotation
			// it is an advantage for the visually impaired
			// but the sighted can also guess that there is a rotation in many cases
			// just looking at the content of the element
			// so we let the description starting with a edge which is not a north one
			let list=pZ.figure.querySelectorAll('.selected');
			if(list&&list.length)
			{
				// describe selected elements
				let s="",len=list.length;
				if(len>1) s+=len+pZ.locale(" selected puzzle elements! ");
				else s+=1+pZ.locale(" selected puzzle element! ");
				for(let ee of list)
					s+=pZ.doOneElementDescription(ee,longDescOn)+pZ.locale(". ");
				pZ.updateMessenger(s);
			}
			else if(e?.classList?.contains("puzzleElement"))
			{
				let s=pZ.doOneElementDescription(e,longDescOn);
				pZ.updateMessenger(s);
			}
		}
	}
	pZ.updateSelectedElements=function()
	{
		if(!pZ.selectedArea) return;
		let b1=pZ.selectedArea.getBoundingClientRect();
		pZ.selectedElements=[];
		for(let e of pZ.figure.querySelectorAll(".puzzleElement"))
		{
			let b2=e.querySelector('.outline').getBoundingClientRect();
			// on firefox, getBoundingClientRect() seems to need the path has a fill or stroke color not set to none
			if((b2.left>=(b1.left-1))
				&&(b2.top>=(b1.top-1))
				&&(b2.bottom<=(b1.bottom+1))
				&&(b2.right<=(b1.right+1)))
				pZ.selectedElements.push(e);
		}
	}
	pZ.doArrowMoveOneElement=function(ev,e)
	{
		let x1,y1,x2,y2,x3,y3,be,bf,i,j,d=pZ.moveStep*pZ.esz00,dw,dh;
		let exRotation;
		if(pZ.rotationOn)
		{
			exRotation=e.pZ.rotation;
			e.pZ.rotation=0;
			pZ.rotate2(e);
		}
		be=e.getBoundingClientRect();
		bf=pZ.figure.getBoundingClientRect();
		x1=Math.round((be.x-bf.x)/pZ.rf)+pZ.to;
		y1=Math.round((be.y-bf.y)/pZ.rf)+pZ.to;
		x3=Math.round(x1/d)*d;
		y3=Math.round(y1/d)*d;
		dw=pZ.nearlyEqual(x1,x3)?d:(x1<x3)?(d+x1-x3):(d+x3-x1);
		dh=pZ.nearlyEqual(y1,y3)?d:(y1<y3)?(d+y1-y3):(d+y3-y1);
		switch(ev.key)
		{
			case "ArrowLeft":x2=x1-dw;y2=Math.round(y1/d)*d;break;
			case "ArrowRight":x2=x1+dw;y2=Math.round(y1/d)*d;break;
			case "ArrowUp":x2=Math.round(x1/d)*d;y2=y1-dh;break;
			case "ArrowDown":x2=Math.round(x1/d)*d;y2=y1+dh;break;
		}
		if(!pZ.nearlyEqual(x1,x2)||!pZ.nearlyEqual(y1,y2))
		{
			pZ.minMaxChange=0;
			i=e.pZ.m.i;
			j=e.pZ.m.j;
			let x=x2/pZ.esz;
			let y=y2/pZ.esz;
			e.pZ.x=x;
			e.pZ.y=y;
			if(pZ.rotationOn)
			{
				e.pZ.rotation=exRotation;
				pZ.rotate2(e);
			}
			let left=x*pZ.esz-pZ.to,top=y*pZ.esz-pZ.to;
			e.style.left=left+"px";
			e.style.top=top+"px";
			pZ.updateMinMax(left,top);
			if(pZ.minMaxChange) pZ.adaptScrollArea();
			pZ.saveElement(e);
			pZ.updatePuzzleElementLabel(e);
			pZ.updateMessenger(e.ariaLabel);
			// is it appropriate to force this scroll?
			// seems not well working on chrome and safari for large puzzle elements
			e.scrollIntoView({block:"nearest",inline:"nearest"});
		}
		else if(pZ.rotationOn)
		{
			e.pZ.rotation=exRotation;
			pZ.rotate2(e);
		}
	}
	pZ.doArrowWhenPuzzleElementOnFocus=function(ev)
	{
		// move all selected elements (but pZ.selectedElements no longer exists)
		ev.preventDefault();
		ev.stopPropagation();
		if(pZ.moveLocked) return; // otherwise the element move can be strange
		pZ.clearSelectedArea(); // require if an arrow key is pressed after moving the selection with the mouse
		if(pZ.hasSomeSelectedByKeyboard)
		{
			let list=pZ.board.querySelectorAll('svg.selected');
			for(let e of list) pZ.doArrowMoveOneElement(ev,e);
		}
		else
		{
			e=document.activeElement;
			pZ.doArrowMoveOneElement(ev,e);
		}
		pZ.dirty=1;
	}
	pZ.doShiftArrow=function(ev)
	{
		// create pZ.selectedArea if not already created, or move it of one moveStep
		let x1,y1,x2,y2,x3,y3,be,bf,i,j,d=pZ.moveStep*pZ.esz00,dl,dr,dt,db;
		ev.preventDefault();
		ev.stopPropagation();
		if(pZ.moveLocked) return; // otherwise the element move can be strange
		let a=document.activeElement;
		a.blur();
		if(!pZ.selectedArea)
		{
			// create selectedArea
			let x,y;
			if(a&&a.classList&&a.classList.contains("puzzleElement"))
			{
				let ba=a.getBoundingClientRect();
				let bf=pZ.figure.getBoundingClientRect();
				x=Math.round((ba.x-bf.x)/pZ.rf);
				y=Math.round((ba.y-bf.y)/pZ.rf);
			}
			else
			{
				x=-pZ.to;
				y=-pZ.to;
			}
			let w=pZ.esz2to,h=pZ.esz2to;
			pZ.selectedArea=document.createElement("div");
			pZ.selectedArea.classList.add("selectedArea");
			pZ.selectedArea.style.setProperty("left",x+"px");
			pZ.selectedArea.style.setProperty("top",y+"px");
			pZ.selectedArea.style.setProperty("width",w+"px");
			pZ.selectedArea.style.setProperty("height",h+"px");
			pZ.selectedArea.style.setProperty("z-index",pZ.zIndex);
			pZ.figure.append(pZ.selectedArea);
			pZ.selectedArea.focus();
			let s;
			s=pZ.locale("Selection area created at ");
			s+=pZ.locale("(")+pZ.a2A(x)+pZ.locale(", ")+pZ.a2A(y)+pZ.locale(")");
			s+=pZ.locale(", ")+pZ.locale("width: ")+pZ.b2B(w);
			s+=pZ.locale(", ")+pZ.locale("height: ")+pZ.b2B(h);
			pZ.updateMessenger(s);
		}
		else
		{
			// enlarge selectedArea
			let d=pZ.moveStep*pZ.esz00;
			let e=pZ.selectedArea;
			let be=e.getBoundingClientRect();
			let bf=pZ.figure.getBoundingClientRect();
			let w,h,xl,yt,xr,yb,w2,h2,xl2,yt2,xr2,yb2;
			w2=w=Math.max(Math.round(be.width/pZ.rf),pZ.esz2to);
			h2=h=Math.max(Math.round(be.height/pZ.rf),pZ.esz2to);
			xl2=xl=Math.round((be.x-bf.x)/pZ.rf);
			yt2=yt=Math.round((be.y-bf.y)/pZ.rf);
			xr2=xr=xl+w;
			yb2=yb=yt+h;
			switch(ev.key)
			{
				case "ArrowLeft":xr2-=d;xr2=Math.max(xl2+pZ.esz2to,xr2);break;
				case "ArrowRight":xr2+=d;xr2=Math.max(xl2+pZ.esz2to,xr2);break;
				case "ArrowUp":yb2-=d;yb2=Math.max(yt2+pZ.esz2to,yb2);break;
				case "ArrowDown":yb2+=d;yb2=Math.max(yt2+pZ.esz2to,yb2);break;
			}
			let modif=0;
			if((xl!=xl2)||(yt!=yt2)||(xr!=xr2)||(yb!=yb2))
			{
				w2=Math.max(Math.round(Math.abs(xr2-xl2)),pZ.esz2to);
				h2=Math.max(Math.round(Math.abs(yb2-yt2)),pZ.esz2to);
				pZ.selectedArea.style.setProperty("left",xl2+"px");
				pZ.selectedArea.style.setProperty("top",yt2+"px");
				pZ.selectedArea.style.setProperty("width",w2+"px");
				pZ.selectedArea.style.setProperty("height",h2+"px");
				modif=1;
			}
			let s;
			if(modif)
			{
				s=pZ.locale("Selection area modified at ");
				s+=pZ.locale("(")+pZ.a2A(xl2)+pZ.locale(", ")+pZ.a2A(yt2)+pZ.locale(")");
				s+=pZ.locale(", ")+pZ.locale("width: ")+pZ.b2B(w2);
				s+=pZ.locale(", ")+pZ.locale("height: ")+pZ.b2B(h2);
			}
			else s=pZ.locale("Selection area not modified");
			pZ.updateMessenger(s);
		}
		pZ.updateSelectedElements();
		pZ.selectedArea.scrollIntoView({block:"nearest",inline:"nearest"});
	}
	pZ.doArrowWhenSelectedArea=function(ev)
	{
		// assume pZ.selectedArea already exists
		// move the selected Area without the selected puzzle elements
		// then update selectedElements
		let e=pZ.selectedArea,be,bf;
		let x1,x2,x3,y1,y2,y3,d,dl,dt,dr,db,w,h;
		ev.preventDefault();
		ev.stopPropagation();
		if(pZ.moveLocked) return; // otherwise the element move can be strange
		d=pZ.moveStep*pZ.esz00;
		be=e.getBoundingClientRect();
		bf=pZ.figure.getBoundingClientRect();
		w=Math.max(be.width/pZ.rf,pZ.esz2to);
		h=Math.max(be.height/pZ.rf,pZ.esz2to);
		x1=Math.round((be.x-bf.x)/pZ.rf)+pZ.to;
		y1=Math.round((be.y-bf.y)/pZ.rf)+pZ.to;
		x3=Math.round(x1/d)*d;
		y3=Math.round(y1/d)*d;
		dl=pZ.nearlyEqual(x1,x3)?d:(x1<x3)?(d+x1-x3):(d+x3-x1);
		dr=pZ.nearlyEqual(x1,x3)?d:(x1<x3)?(d+x1-x3):(d+x3-x1);
		dt=pZ.nearlyEqual(y1,y3)?d:(y1<y3)?(d+y1-y3):(d+y3-y1);
		db=pZ.nearlyEqual(y1,y3)?d:(y1<y3)?(d+y1-y3):(d+y3-y1);
		switch(ev.key)
		{
			case "ArrowLeft":x2=x1-dl;y2=Math.round(y1/d)*d;break;
			case "ArrowRight":x2=x1+dr;y2=Math.round(y1/d)*d;break;
			case "ArrowUp":x2=Math.round(x1/d)*d;y2=y1-dt;break;
			case "ArrowDown":x2=Math.round(x1/d)*d;y2=y1+db;break;
		}
		let x=x2/pZ.esz;
		let y=y2/pZ.esz;
		let left=x*pZ.esz-pZ.to,top=y*pZ.esz-pZ.to;
		e.style.left=left+"px";
		e.style.top=top+"px";
		e.style.width=w+"px";
		e.style.height=h+"px";
		pZ.updateSelectedElements();
		let s;
		s=pZ.locale("Selection area moved to ");
		s+=pZ.locale("(")+pZ.a2A(left)+pZ.locale(", ")+pZ.a2A(top)+pZ.locale(")");
		s+=pZ.locale(", ")+pZ.locale("width: ")+pZ.b2B(w);
		s+=pZ.locale(", ")+pZ.locale("height: ")+pZ.b2B(h);
		pZ.updateMessenger(s);
		pZ.selectedArea.scrollIntoView({block:"nearest",inline:"nearest"});
	}
	pZ.getZIndex=function(e)
	{      
		let z=getComputedStyle(e).getPropertyValue('z-index');
		if (isNaN(z)) return 0;
		return z; 
	}
	pZ.cancelSelect=function()
	{
		pZ.clearSelectedArea();
		if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
		document.activeElement.blur();
		pZ.updateMessenger(pZ.locale("Nothing is selected or is in focus anymore."));
	}
	pZ.doKeydown=function(ev)
	{
		if(pZ.inDialog) return;
		if(ev.key=="Tab")
		{
			// let the default scrolling happen here, in case the user wants it
			pZ.clearSelectedArea();
			if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
			if(pZ.tabTofirst)
			{
				// force to tab on accessibility button when the first tab occurs
				// otherwise the focused element could be anywhere
				pZ.tabTofirst=0;
				pZ.accessibility.focus();
				ev.preventDefault();
			}
			return;
		}
		if(ev.altKey||ev.ctrlKey||ev.metaKey) return;
		let a=document.activeElement;
		pZ.tabTofirst=0;
		// to use the default scroll,
		// the user can give focus to a button of the menu before scrolling
		if(ev.shiftKey&&["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(ev.key))
		{
			// create or modify selection area
			if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
			pZ.doShiftArrow(ev);
			return;
		}
		if(a&&a.classList&&a.classList.contains("puzzleElement")
			&&["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(ev.key))
		{
			// move selected elements
			pZ.doArrowWhenPuzzleElementOnFocus(ev);
			return;
		}
		if(pZ.selectedArea&&["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(ev.key))
		{
			// move the selected area without its content
			pZ.doArrowWhenSelectedArea(ev);
			return;
		}
		if(a?.classList?.contains("puzzleElement")&&(ev.key==" "))
		{
			ev.preventDefault();
			ev.stopPropagation();
			// check match
			if(pZ.hasSomeSelectedByKeyboard)
			{
				let eList,ef=null,zm=0;
				eList=pZ.board.querySelectorAll('svg.puzzleElement.selected');
				if(pZ.rotationOn&&ev.shiftKey)
				{
					for(let e of eList) if(pZ.rotationOn&&ev.shiftKey) pZ.rotate(e,90);
					pZ.updateMessenger(pZ.locale("Rotation"));
				}
				else
				{
					pZ.match(eList);
					// when several groups of elements match, the focus can be lost
					// give again the focus to the top most element amid selected elements
					// rebuild the eList since they may be less elements than before matching
					eList=pZ.board.querySelectorAll('svg.puzzleElement.selected');
					for(let e of eList)
					{
						let z=pZ.getZIndex(e);
						if(z>=zm) {ef=e;zm=z;}
					}
					if(ef) ef.focus();
				}
			}
			else
			{
				if(pZ.rotationOn&&ev.shiftKey)
				{
					pZ.rotate(a,90);
					pZ.updateMessenger(pZ.locale("Rotation"));
				}
				else pZ.match([a]);
			}
			return;
		}
		if(pZ.selectedArea&&(ev.key==" "))
		{
			// give the focus to the top most element inside pZ.selectedElements
			// if shiftKey, mark as selected all elements inside pZ.selectedElements
			// else mark as selected only the top most element
			ev.preventDefault();
			ev.stopPropagation();
			let ef=null,zm=0;
			for(let e of pZ.selectedElements)
			{
				let z=pZ.getZIndex(e);
				if(z>=zm) {ef=e;zm=z;}
			}
			if(ef&&!ev.shiftKey) pZ.selectedElements=[ef];
			if(pZ.selectedElements.length>1) pZ.updateMessenger(pZ.locale("Multiple elements selected!"));
			for(let e of pZ.selectedElements)
			{
				e.classList.add("selected");
				pZ.hasSomeSelectedByKeyboard=1;
			}
			for(let e of pZ.selectedElements) if(e!=ef) pZ.sendAbove(e);
			if(ef)
			{
				if(ef!=document.activeElement) ef.focus();
				pZ.sendAbove(ef);
				// do not pZ.clearSelectedByKeyboard() here
			}
			pZ.clearSelectedArea();
			return;
		}
		// manage shortcuts
		let key=ev.key.toLowerCase();
		if(key.match(/^[abdefghprt]$/))
		{
			ev.preventDefault();
			ev.stopPropagation();
			switch(key)
			{
				case "a":pZ.doClickOnAccessibility(ev);break;
				case "b":pZ.doBoard(ev);break;
				case "d":pZ.doDescription(ev,a);break;
				case "e":pZ.doClickOnReframe(ev);break;
				case "f":
					pZ.clearSelectedArea();
					if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
					pZ.ghost.focus();
					break;
				case "g":pZ.cancelSelect();break;
				case "h":
					pZ.clearSelectedArea();
					if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
					pZ.home.focus();
					break;
				case "p":pZ.doClickOnPreferences(ev);break;
				case "r":
					pZ.clearSelectedArea();
					if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
					pZ.restart.focus();break;
				case "t":pZ.doTipsAndTricksAlert();break;
			}
		}
	}
	pZ.clearSelectedByKeyboard=function()
	{
		if(!pZ.figure) return;
		let eList=pZ.figure.querySelectorAll('svg.puzzleElement.selected');
		for(let e of eList) e.classList.remove("selected");
		pZ.hasSomeSelectedByKeyboard=0;
	}
	pZ.clearSelectedArea=function()
	{
		if(pZ.selectedArea){pZ.selectedArea.remove();pZ.selectedArea=null;}
		pZ.selectedElements=[];
	}
	pZ.selectContinue=function(ev)
	{
		if(!ev.isPrimary) return;
		// give touchscreen users time to scroll instead of selecting
		if((ev.timeStamp-pZ.selectStartTime)<500) return;
		if(pZ.selectE&&(pZ.selectE.hasPointerCapture(ev.pointerId)))
		{
			if(!pZ.selectedArea)
			{
				pZ.selectedArea=document.createElement("div");
				pZ.selectedArea.classList.add("selectedArea");
				pZ.selectedArea.style.setProperty("z-index",pZ.zIndex);
				pZ.selectedArea.style.setProperty("left",(pZ.selectX-pZ.figureX)/pZ.rf+"px");
				pZ.selectedArea.style.setProperty("top",(pZ.selectY-pZ.figureY)/pZ.rf+"px");
				pZ.selectedArea.style.setProperty("width","0");
				pZ.selectedArea.style.setProperty("height","0");
				pZ.selectedArea.style.setProperty("pointer-events","none");
				pZ.figure.append(pZ.selectedArea);
			}
			else
			{
				let x=ev.clientX,y=ev.clientY;
				pZ.selectedArea.style.setProperty("left",(Math.min(x,pZ.selectX)-pZ.figureX)/pZ.rf+"px");
				pZ.selectedArea.style.setProperty("top",(Math.min(y,pZ.selectY)-pZ.figureY)/pZ.rf+"px");
				pZ.selectedArea.style.setProperty("width",Math.abs(x-pZ.selectX)/pZ.rf+"px");
				pZ.selectedArea.style.setProperty("height",Math.abs(y-pZ.selectY)/pZ.rf+"px");
			}
		}
	}
	pZ.selectStart=function(ev)
	{
		if(!ev.isPrimary) return;
		if(ev.altKey||ev.ctrlKey||ev.metaKey) return;
		pZ.clearSelectedArea();
		if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
		let e=pZ.getSvg(ev,"background");
		if(!e) return;
		e.addEventListener('pointermove',pZ.selectContinue);
		e.setPointerCapture(ev.pointerId);
		let bf=pZ.figure.getBoundingClientRect();
		pZ.figureX=bf.x;
		pZ.figureY=bf.y;
		pZ.selectE=e;
		pZ.selectX=ev.clientX;
		pZ.selectY=ev.clientY;
		pZ.selectStartTime=ev.timeStamp;
	}
	pZ.selectEnd=function(ev)
	{
		if(!ev.isPrimary) return;
		let e=pZ.getSvg(ev,"background");
		if(!e) return;
		if(e.hasPointerCapture(ev.pointerId)) e.releasePointerCapture(ev.pointerId);
		e.removeEventListener('pointermove',pZ.selectContinue);
		if(pZ.selectE&&(e==pZ.selectE)&&pZ.selectedArea)
		{
			pZ.updateSelectedElements();
		}
		else
		{
			pZ.clearSelectedArea();
			if(pZ.hasSomeSelectedByKeyboard) pZ.clearSelectedByKeyboard();
		}
		pZ.selectE=null;
	}
	pZ.initBackground=function()
	{
		pZ.background=document.createElementNS('http://www.w3.org/2000/svg','svg');
		pZ.background.classList.add("background");
		pZ.background.innerHTML="<rect/>";
		pZ.background.addEventListener("pointerdown",pZ.selectStart);
		pZ.background.addEventListener("pointerup",pZ.selectEnd);
		pZ.currentScript.after(pZ.background);
		pZ.selectedElements=[];
	}
	pZ.initParameters=function()
	{
		if(localStorage.pZ_whmax===undefined) localStorage.pZ_whmax=pZ.whmax=pZ.defaultParams.whmax;
		else pZ.whmax=-(-localStorage.pZ_whmax); // number of piece on the width of the puzzle
		if(localStorage.pZ_pt===undefined) localStorage.pZ_pt=pZ.pt=pZ.defaultParams.pt;
		else pZ.pt=localStorage.pZ_pt; // puzzle element type (squared, curvy, quirky)
		if(localStorage.pZ_emb===undefined) localStorage.pZ_emb=pZ.emboss=pZ.defaultParams.emb;
		else pZ.emboss=-(-localStorage.pZ_emb); // emboss effect, if 0 then no piece borders
		if(localStorage.pZ_th===undefined) localStorage.pZ_th=pZ.threshold=pZ.defaultParams.th; // better if more than half moveStep below
		else pZ.threshold=-(-localStorage.pZ_th); // threshold to stick a puzzle element in its place
		if(localStorage.pZ_ms===undefined) localStorage.pZ_ms=pZ.moveStep=pZ.defaultParams.ms;
		else pZ.moveStep=-(-localStorage.pZ_ms); // step when moving a puzzle element using the keyboard
		if(localStorage.pZ_ro===undefined) localStorage.pZ_ro=pZ.rotationOn=pZ.defaultParams.ro;
		else pZ.rotationOn=-(-localStorage.pZ_ro); // if 1, rotation is on
		if(localStorage.pZ_ric===undefined) localStorage.pZ_ric=pZ.roundInitialCoordinates=pZ.defaultParams.ric;
		else pZ.roundInitialCoordinates=-(-localStorage.pZ_ric); // if 1, round initial coordinates of a puzzle element to a multiple of pZ.moveStep
		if(localStorage.pZ_showsw===undefined) localStorage.pZ_showsw=pZ.showStopwatch=pZ.defaultParams.showsw;
		else pZ.showStopwatch=-(-localStorage.pZ_showsw); // if 1, show the stopwatch
		if(localStorage.pZ_showsc===undefined) localStorage.pZ_showsc=pZ.showScore=pZ.defaultParams.showsc;
		else pZ.showScore=-(-localStorage.pZ_showsc); // if 1, show the score
		if(localStorage.pZ_showgh===undefined) localStorage.pZ_showgh=pZ.showGhost=pZ.defaultParams.showgh;
		else pZ.showGhost=-(-localStorage.pZ_showgh); // if 1, show the ghost
		if(localStorage.pZ_scatter===undefined) localStorage.pZ_scatter=pZ.scatter=pZ.defaultParams.scatter;
		else pZ.scatter=localStorage.pZ_scatter; // "inside" or "outside"
		if(localStorage.pZ_bkc===undefined) localStorage.pZ_bkc=pZ.bkColor=pZ.defaultParams.bkc;
		else pZ.bkColor=localStorage.pZ_bkc;
		if(localStorage.pZ_bo===undefined) localStorage.pZ_bo=pZ.beepOn=pZ.defaultParams.bo;
		else pZ.beepOn=-(-localStorage.pZ_bo); // if 1, beep when matching
	}
	pZ.initFirst=function()
	{
		pZ.board.classList.replace("initial","puzzle");
		document.addEventListener("keydown",pZ.doKeydown);
		pZ.initBackground();
		// board
		pZ.rf=1;
		pZ.initParameters();
		pZ.setBkColor();
		pZ.initMenu();
		pZ.initStopwatch();
		pZ.initScore();
		pZ.initGhost();
		// observing the board cost too much, thus observe the menu
		new ResizeObserver((es)=>
		{
			if(!pZ.resizeCounter) pZ.resizeCounter=1;
			else pZ.resizeCounter++;
			let currentCounter=pZ.resizeCounter;
			setTimeout(function()
			{
				if(currentCounter>=pZ.resizeCounter)
				{
					pZ.adaptScrollArea();
					pZ.resizeCounter=0;
				}
			},1000);
		}).observe(pZ.menu);
		setTimeout(()=>pZ.initPuzzle(),100);
	}
	pZ.fetch=function(o={})
	{
		pZ.showWait();
		fetch(pZ.restoreOn?localStorage.imgDataUrl:pZ.imgUrl,o)
		.then((r)=>
		{
			if (r.ok) return r.blob();
			throw new Error(pZ.locale("Error retrieving data"));
		})
		.then((b)=>
		{
			if(pZ.restoreOn)
			{
				// localStorage.imgDataUrl must not and cannot be null here
				pZ.imgDataUrl=localStorage.imgDataUrl;
				pZ.imgUrl=URL.createObjectURL(b);
				setTimeout(()=>pZ.loader(0),100);
			}
			else
			{
				const reader=new FileReader();
				let svgImgOn=b.type.match(/svg\+xml$/i)?1:0;
				reader.addEventListener("load",()=>
				{
					if(svgImgOn) pZ.imgDataUrl=pZ.setWHToSvg(reader.result);
					else pZ.imgDataUrl=reader.result;
					pZ.loader(svgImgOn);
				});
				if(svgImgOn) reader.readAsText(b);
				else reader.readAsDataURL(b);
			}
		})
		.catch((e)=>{pZ.imgUrl=pZ.defaultImgUrl;pZ.fetch();});
	}
	pZ.makeInitialImgBtn=function(a,k)
	{
		let s="",title=(pZ.lang=="fr")?a.image_title_fr:a.image_title_en;
		let cls="";
		if(a.ratio)
		{
			let ra,r=0;
			ra=a.ratio.split(":");
			if((ra.length==2)&&ra[0].match(/^\d+$/)&&ra[1].match(/^\d+$/))
			{
				r=-ra[0]/-ra[1];
				if(r<1) cls="vertical";
				else if(r>1) cls="horizontal";
				else cls="square";
			}
		}
		s+="<li>";
		s+="<button data-k=\""+k+"\" title=\""+title+"\" type=\"button\" class=\"imgSelector\" value=\""+a.file_name+"\">";
		s+="<img class=\""+cls+"\" alt=\"\" src=\""+a.thumbnail+"\" loading=\"lazy\">";
		s+="</button>";
		s+="<button title=\""+pZ.locale("About this image")+"\" data-k=\""+k+"\" type=\"button\" class=\"imgAlert\">";
		s+="<span aria-hidden=\"true\">"+title+"</span>";
		s+="</button>";
		s+="</li>";
		return s;
	}
	pZ.imgData=function(a)
	{
		let s="<p>";
		s+=(pZ.lang=="fr")?a.image_title_fr:a.image_title_en;
		s+="</p>";
		if(a["owner"])
		{
			s+="<p>";
			s+=pZ.locale("Credits: ");
			if(a["source"]&&a["source"].match(/^(http|_img)/))
			{
				s+="<a href=\""+a["source"]+"\" target=\"_blank\">"+a["owner"]+"</a>";
			}
			else s+=a["owner"];
			s+="</p>";
		}
		else if(a["source"]&&(a["source"]!="?"))
		{
			if(a["source"]=="generated by an AI")
				s+="<p>"+pZ.ucFirst(pZ.locale("generated by an AI"))+"</p>";
			else if(a["source"]=="Parsimonhi")
			{
				s+=pZ.locale("Credits: ");
				s+="<p>"+pZ.ucFirst(pZ.locale("Parismonhi"))+"</p>";
			}
			else
			{
				s+="<p><a href=\""+a["source"]+"\" target=\"_blank\">";
				s+=pZ.locale("Source");
				s+="</a></p>";
			}
		}
		if(a["license"])
		{
			s+="<p>"+pZ.locale("License: ");
			if(a["license"]=="Public-domain") s+=pZ.locale("Public domain");
			else
			{
				let licenseLabel="",licenseLink="";
				for(let e of pZ.licensesJson)
				{
					if(e["license_code"]==a["license"])
					{
						licenseLink=e["license_link"];
						break;
					}
				}
				if(licenseLink) s+="<a href=\""+licenseLink+"\">";
				s+=pZ.ucFirst(a["license"]);
				if(licenseLink) s+="</a>";
			}
			s+="</p>";
		}
		s+="<p>"+pZ.locale("To launch the puzzle, click on the image!")+"</p>";
		return s;
	}
	pZ.dragOverHandler=function(e)
	{
		const files=[...e.dataTransfer.items].filter((item)=>item.kind==="file");
		if(files.length==1)
		{
			e.preventDefault();
			if (files.some((item)=>item.type.startsWith("image/")))
				e.dataTransfer.dropEffect="copy";
			else e.dataTransfer.dropEffect="none";
		}
	}
	window.addEventListener("dragover",(e)=>
	{
		const files=[...e.dataTransfer.items].filter((item)=>item.kind==="file");
		if(files.length==1)
		{
			e.preventDefault();
			if(!pZ.dropZone.contains(e.target)) e.dataTransfer.dropEffect="none";
		}
	});
	pZ.dropHandler=function(ev)
	{
		ev.preventDefault();
		pZ.doReadFile([...ev.dataTransfer.items].map((item)=>item.getAsFile())[0]);
	}
	window.addEventListener("drop",(e)=>
	{
		if([...e.dataTransfer.items].some((item)=>item.kind==="file")) e.preventDefault();
	});
	
	pZ.doChooseContinue2=function()
	{
		// choose an image on a server
		let t=pZ.locale("Choose an image"),s="";
		let categories=[];
		if(pZ.lang.match(/^fr/))
		{
			categories.push({title:"Animals",type:"animal"});
			categories.push({title:"Art",type:"art"});
			categories.push({title:"Building",type:"building"});
			categories.push({title:"Flags",type:"flag"});
			categories.push({title:"Miscellaneous",type:"misc"});
			categories.push({title:"Objects",type:"object"});
			categories.push({title:"Landscapes",type:"landscape"});
			categories.push({title:"Plants",type:"plant"});
			categories.push({title:"Transport",type:"transport"});
			categories.push({title:"Clothing",type:"clothing"});
		}
		else
		{
			categories.push({title:"Animals",type:"animal"});
			categories.push({title:"Art",type:"art"});
			categories.push({title:"Building",type:"building"});
			categories.push({title:"Clothing",type:"clothing"});
			categories.push({title:"Flags",type:"flag"});
			categories.push({title:"Landscapes",type:"landscape"});
			categories.push({title:"Miscellaneous",type:"misc"});
			categories.push({title:"Objects",type:"object"});
			categories.push({title:"Plants",type:"plant"});
			categories.push({title:"Transport",type:"transport"});
		}
		s+="<section class=\"preferences\"><h2>"+pZ.locale("Settings")+"</h2>";
		s+="<button id=\"modify-settings\" class=\"standardBtn\" type=\"button\">"+pZ.locale("Modify")+"</button>";
		s+="</section><section class=\"tipsAndTricks\">";
		s+="<h2>"+pZ.locale("Tips and Tricks")+"</h2>";
		s+="<button id=\"tips-and-tricks\" class=\"standardBtn\" type=\"button\">"+pZ.locale("Read")+"</button>";
		s+="</section><section class=\"chooseAnImage\" class=\"tipsAndTricks\">";
		s+="<h2>"+t+"</h2>"
		s+="<label id=\"drop-zone\">";
		s+="<span>"+pZ.locale("Drag and drop one of your images here or select one by clicking the button below:")+"</span>";
		s+="<input type=\"file\" accept=\"image/*\">";
		s+="</label>";
		s+="<p>"+pZ.locale("You can also select one of the images below by clicking on it:")+"</p>";
		let listOfImages=[],k=0;
		if(pZ.all) for(let c of categories)
		{
			s+="<details><summary>"+pZ.locale(c.title)+"</summary>";
			s+="<ul class=\"imgList\">";
			for(let a of pZ.originJson)
			{
				if((a.category==c.type)&&(a.visible=="1"))
				{
					k++;
					listOfImages[k]=a;
					s+=pZ.makeInitialImgBtn(a,k);
				}
			}
			s+="</ul>"
			s+="</details>";
		}
		else
		{
			s+="<ul class=\"imgList\">";
			for(let a of pZ.originJson) if(a.always=="1")
			{
				k++;
				listOfImages[k]=a;
				s+=pZ.makeInitialImgBtn(a,k);
			}
			s+="</ul>"
		}
		s+="</section>";
		pZ.board.innerHTML=s;
		let i=document.querySelector('input[type="file"]');
		if(i) i.addEventListener("change",pZ.doChangeFile);
		let bs;
		bs=document.getElementById('modify-settings');
		if(bs) bs.addEventListener("click",(ev)=>
		{
			pZ.initParameters();
			pZ.doClickOnPreferences(ev);
		});
		bs=document.getElementById('tips-and-tricks');
		if(bs) bs.addEventListener("click",(ev)=>
		{
			pZ.doClickOnTipsAndTricks(ev);
		});
		let list=pZ.board.querySelectorAll('.board.initial button.imgSelector');
		for(let b of list)
		{
			b.addEventListener('click',function()
			{
				pZ.imgUrl=b.value;
				pZ.board.innerHTML="";
				// may consider pZ.fetch({mode:"cors"});
				// without the "cors" option, one can receive an "opaque" response
				// with some picture such as https://upload.wikimedia.org/wikipedia/commons/f/f0/Crown_Jewels_of_the_United_Kingdom_1952-12-13.jpg
				pZ.fetch();
			});
		}
		let list2=pZ.board.querySelectorAll('.board.initial button.imgAlert');
		for(let b2 of list2)
		{
			let k=-(-b2.getAttribute("data-k"));
			b2.addEventListener('click',function()
			{
				pZ.noH2Outline=1;
				pZ.doAlert(pZ.locale("About this image"),pZ.imgData(listOfImages[k]));
			});
		}
		pZ.dropZone=document.getElementById("drop-zone");
		pZ.dropZone.addEventListener("drop",pZ.dropHandler);
		pZ.dropZone.addEventListener("dragover",pZ.dragOverHandler);
	}
	pZ.doChooseContinue=function()
	{
		fetch("licenses.json",{cache:"no-cache"})
		.then(r=>r.json())
		.then(j=>{pZ.licensesJson=j;pZ.doChooseContinue2();});
	}
	pZ.choose=function()
	{
		fetch("images.json",{cache:"no-cache"})
		.then(r=>r.json())
		.then(j=>{pZ.originJson=pZ.shuffleArray(j);pZ.doChooseContinue();});
	}
	pZ.doRestoreContinue=function()
	{
		pZ.restoreOn=1;
		pZ.fetch();
	}
	pZ.doRestoreCancel=function()
	{
		// must be named "doRestoreCancel" to be also fired when the "esc" key is pressed
		pZ.clearRestoreData();
		pZ.choose();
	}
	pZ.doRestoreDialog=function()
	{
		let t=pZ.locale("Restore"),s,
			o=[{n:"Restore",a:"RestoreContinue"},{n:"Remove",l:"Do not restore",a:"RestoreCancel"}];
		s="<p>"+pZ.locale("A puzzle has not been completed.")+"</p>";
		pZ.noH2Outline=1;
		pZ.doDialog("Restore",t,s,o);
	}
	pZ.start2=function()
	{
		pZ.defaultParams=
		{
			whmax:100,
			pt:"quirky",
			emb:5,
			th:30,
			ms:50,
			ro:0,
			ric:1,
			showsw:1,
			showsc:1,
			showgh:1,
			scatter:"inside",
			bkc:"#ffffff",
			bo:1
		};
		pZ.maxLoadingTime=50*pZ.iwhMax;
		pZ.board=document.createElement('main');
		pZ.board.classList.add("board","initial");
		pZ.currentScript.after(pZ.board);
		pZ.initWait();
		if(localStorage.imgDataUrl) pZ.doRestoreDialog();
		else pZ.choose();
	}
	pZ.start=function()
	{
		if(pZ.lang.match(/^fr/))
		{
			fetch("_i18n/puzzle-i18n-fr.json",{cache:"no-cache"})
			.then(r=>r.json())
			.then(j=>{pZ.i18n=j;pZ.start2();});
		}
		else pZ.start2();
	}
	pZ.search=window.location.search.replace(/[^?A-Za-z0-9=]/g,"");
	pZ.all=((pZ.hashCode(pZ.search)+"")==="1908939687");
	pZ.currentScript=document.currentScript;
	pZ.lang=pZ.getLang();
	document.documentElement.lang=pZ.lang;
	// 2520: smallest number divisible by all integers from 1 to 10
	// 1280: common width on Wikimedia Commons
	// choose a value small enough to produce PNG data URL lenght < 4000000
	// otherwise, the image will be not saved in the localStorage
	pZ.iwhMax=1280;
	pZ.defaultImgUrl="_icon/puzzle-not-found.svg"; // default img in case of problem
	pZ.imgUrl=pZ.defaultImgUrl;
	window.addEventListener('load',pZ.start);
})();
</script>
<footer>
<p class="copyright">
<a href="https://github.com/parsimonhi/puzzle23">Puzzle23</a>
<span>Copyright  2024</span>
<a href=\"https://github.com/parsimonhi\">Parsimonhi</a>
</p>
<a href="#">Back to top</a>
</footer>
<script>
window.addEventListener("load",()=>
{
	let y=new Date().getFullYear();
	document.querySelector('.copyright span').innerHTML+=(y!=2024)?"-"+y:"";
	if(document.documentElement.lang.match(/^fr/))
		document.querySelector('footer>a:last-of-type').innerHTML="Haut de page";
});
// register the PWA service worker
if ("serviceWorker" in navigator) {navigator.serviceWorker.register("sw.js");}
</script>
</body>
</html>